<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>potentials_from_particle_insertion API documentation</title>
<meta name="description" content="Description
Python package with a set of functions for calculating the g(r) using the
Widom test-particle insertion method, and/or for fitting the …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>potentials_from_particle_insertion</code></h1>
</header>
<section id="section-intro">
<h2 id="description">Description</h2>
<p>Python package with a set of functions for calculating the g(r) using the
Widom test-particle insertion method, and/or for fitting the g(r) to solve for
the pair-potential using particle coordinates from e.g. confocal microscopy or
cryo-TEM.</p>
<p>The codes for this package were developed as part of the work in reference [1],
where the iterative use of test-particle insertion to solve for the pair
potential was based on [2] with correction for periodic or finite boundary
conditions based on equations described in [3,4]</p>
<h2 id="references">References</h2>
<p>[1] Bransen, M. (2024). Measuring interactions between colloidal
(nano)particles. PhD thesis, Utrecht University.</p>
<p>[2] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2019). Model-Free
Measurement of the Pair Potential in Colloidal Fluids Using Optical Microscopy.
Physical Review Letters, 123(9), 098002.
<a href="https://doi.org/10.1103/PhysRevLett.123.098002">https://doi.org/10.1103/PhysRevLett.123.098002</a></p>
<p>[3] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
periodic boundary conditions.
<a href="https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf">https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf</a></p>
<p>[4] Kopera, B. A. F., &amp; Retsch, M. (2018). Computing the 3D Radial Distribution
Function from Particle Positions: An Advanced Analytic Approach. Analytical
Chemistry, 90(23), 13909–13914.
<a href="https://doi.org/10.1021/acs.analchem.8b03157">https://doi.org/10.1021/acs.analchem.8b03157</a></p>
<h2 id="license">License</h2>
<p>MIT license</p>
<p>Copyright (c) 2024 Maarten Bransen</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="potentials_from_particle_insertion.multicomponent" href="multicomponent/index.html">potentials_from_particle_insertion.multicomponent</a></code></dt>
<dd>
<div class="desc"><p>This file contains codes for multicomponent compatible versions of functions,
i.e. for more than one 'type' of particle …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="potentials_from_particle_insertion.load_TPI_results"><code class="name flex">
<span>def <span class="ident">load_TPI_results</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>loads text file containing TPI results as written by <code>save_tpi_results()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the TPI result file to load</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code></dt>
<dd>lower bound on interparticle distance</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>upper bound on interparticle distance</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code></dt>
<dd>bin width of interparticle distance</dd>
<dt><strong><code>bincentres</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>centre position of each interparticle distance bin</dd>
<dt><strong><code>dhrdf</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>g(r) values from DH calculation for each bin</dd>
<dt><strong><code>rdfs</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>g(r) values from TPI for each bin for each iteration</dd>
<dt><strong><code>potentials</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>u(r) values for each bin for each iteration</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>bin counts for each bin for each iteration</dd>
<dt><strong><code>errors</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>chi squared error for each iteration</dd>
</dl></div>
</dd>
<dt id="potentials_from_particle_insertion.rdf_dist_hist_2d"><code class="name flex">
<span>def <span class="ident">rdf_dist_hist_2d</span></span>(<span>coordinates,<br>rmin=0,<br>rmax=10,<br>dr=None,<br>handle_edge='rectangle',<br>boundary=None,<br>density=None,<br>quiet=False,<br>neighbors_upper_bound=None,<br>workers=1)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates g(r) via a 'conventional' distance histogram method for a
set of 2D coordinate sets. Provided for convenience.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>numpy.array</code> or <code>list-like</code> of <code>numpy.array</code></dt>
<dd>list of sets of coordinates, where each item along the 0th dimension is
a N*2 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one TEM image, a time step from a
video, etc.), with each element of the array of form
<code>[y,x]</code>. Each
set of coordinates is not required to have the same number of particles
but must have the same particle density. When no boundaries or a single
boundary is given, it is assumed all coordinate sets share these same
boundaries.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower bound for the pairwise distance, left edge of 0th bin. The
default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>upper bound for the pairwise distance, right edge of last bin. The
default is 10.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>bin width for the pairwise distance bins. The default is (rmax-rmin)/20</dd>
<dt><strong><code>handle_edge</code></strong> :&ensp;<code>one</code> of <code>['none','rectangle','periodic rectangle','circle', (list of) callable]</code>, optional</dt>
<dd>
<p>specifies how to correct for edge effects in the radial distribution
function. These edge effects occur due to particles closer than <code>rmax</code>
to any of the boundaries missing part of their neighbour shells in the
dataset. The following options for correcting for this are available:</p>
<ul>
<li><code>'none'</code> or <code>None</code> or <code>False</code> (all equivalent): do not correct
for edge effects at all. Note that in order to calculate the
particle density, cuboidal boundaries are assumed even when
<code>boundary</code> is not specified. This can be overridden by explicitely
giving the particle density using the <code>density</code> parameter.</li>
<li><code>'rectangle'</code>: correct for the missing volume in a square or
rectangular boundary.</li>
<li><code>'periodic rectangle'</code>: like <code>'rectangle'</code>, except in periodic
boundary conditions (i.e. one side wraps around to the other),
based on ref [1].</li>
<li><code>'circle'</code>: correct for missing volume in a spherical boundary.</li>
<li>a custom callable function (or list thereof) can be given to
correct for arbitrary and/or mixed boundary conditions. This
function must take three arguments: a numpy array of bin edges, an
N×2 numpy array of coordinates and a boundary as specified in
<code>boundary</code>, and return an N × <code>len(bin edges)-1</code> numpy array with
a value between 0 and 1 specifying the fraction of the volume of
each circular shell that is within the boundary.</li>
</ul>
<p>The default is 'rectangle'.</p>
</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>
<p>positions of the walls that define the bounding box of the coordinates.
The format must be given as <code>((ymin,ymax),(xmin,xmax))</code> when
<code>handle_edge</code> is <code>'none'</code>, <code>'rectangle'</code> or <code>'periodic rectangle'</code>.
When <code>handle_edge='circle'</code> the coordinates of the origin and radius of
the bouding circle must be given as <code>(y,x,radius)</code>. For custom boundary
handling, <code>boundary</code> can be any format as required by the edge
edge correction function(s) passed to <code>handle_edge</code>.</p>
<p>If all coordinate sets share the same boundary, a single such boundary
can be given, otherwise a list of such array-likes of the same length
as coordinates can be given for specifying boundaries of each set in
<code>coordinates</code> separately. The default <code>None</code> which determines the
smallest set of boundaries encompassing a set of coordinates.</p>
</dd>
<dt><strong><code>density</code></strong> :&ensp;<code>float</code> or <code>callable</code> or <code>list</code> of <code>callable</code>, optional</dt>
<dd>number density of particles in the box to use for normalizing the
values. The default is the average density based on <code>coordinates</code> and
<code>boundary</code>. When using custom edge correction in <code>handle_edge</code> it is
possible to instead pass a (list of) callable that takes the number of
particles and boundary and returns the number density.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, no output is printed to the terminal by this function call.
The default is False.</dd>
<dt><strong><code>neighbors_upper_bound</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>upper limit on the number of neighbors expected within rmax from a
particle. Useful for reducing memory consumption in datasets with
dimensions much larger than rmax. The default is None, which takes the
total number of particles in the coordinate set as upper limit.</dd>
<dt><strong><code>workers</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of workers to use for parallel processing during the neighbour
detection step. If -1 is given all CPU threads are used. Note: this is
ignored when <code>handle_edge='periodic rectangle'</code>. The default is 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rvals</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>bin-edges of the radial distribution function.</dd>
<dt><strong><code>bincounts</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>values for the bins of the radial distribution function</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
periodic boundary conditions.
<a href="https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf">https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf</a></p></div>
</dd>
<dt id="potentials_from_particle_insertion.rdf_dist_hist_3d"><code class="name flex">
<span>def <span class="ident">rdf_dist_hist_3d</span></span>(<span>coordinates,<br>rmin=0,<br>rmax=10,<br>dr=None,<br>handle_edge='cuboid',<br>boundary=None,<br>density=None,<br>quiet=False,<br>neighbors_upper_bound=None,<br>workers=1)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates g(r) via a 'conventional' distance histogram method for a
set of 3D coordinate sets. Provided for convenience.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>numpy.array</code> or <code>list-like</code> of <code>numpy.array</code></dt>
<dd>list of sets of coordinates, where each item along the 0th dimension is
a N*3 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one z-stack, a time step from a
video, etc.), with each element of the array of form
<code>[z,y,x]</code>. Each
set of coordinates is not required to have the same number of particles
but must have the same particle density. When no boundaries or a single
boundary is given, it is assumed all coordinate sets share these same
boundaries.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower bound for the pairwise distance, left edge of 0th bin. The
default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>upper bound for the pairwise distance, right edge of last bin. The
default is 10.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>bin width for the pairwise distance bins. The default is (rmax-rmin)/20</dd>
<dt><strong><code>handle_edge</code></strong> :&ensp;<code>one</code> of <code>['none','cuboid','periodic cuboid','sphere', (list of) callable]</code>, optional</dt>
<dd>
<p>specifies how to correct for edge effects in the radial distribution
function. These edge effects occur due to particles closer than <code>rmax</code>
to any of the boundaries missing part of their neighbour shells in the
dataset. The following options for correcting for this are available:</p>
<ul>
<li><code>'none'</code> or <code>None</code> or <code>False</code> (all equivalent): do not correct
for edge effects at all. Note that in order to calculate the
particle density, cuboidal boundaries are assumed even when
<code>boundary</code> is not specified. This can be overridden by explicitely
giving the particle density using <code>density</code>.</li>
<li><code>'cuboid'</code>: correct for the missing volume in cuboidal boundary
conditions, e.g. a 3D rectangular box with right angles. Based on
ref. [1]</li>
<li><code>'periodic cuboid'</code>: like <code>'cuboid'</code>, except in periodic
boundary conditions (i.e. one side wraps around to the other).
Based on ref. [2].</li>
<li><code>'sphere'</code>: correct for missing volume in spherical boundary
conditions</li>
<li>a custom callable function (or list thereof) can be given to
correct for arbitrary and/or mixed boundary conditions. This
function must take three arguments: a numpy array of bin edges, an
N×3 numpy array of coordinates and a boundary as specified in
<code>boundary</code>, and return an N × <code>len(bin edges)-1</code> numpy array with
a value between 0 and 1 specifying the fraction of the volume of
each spherical shell that is within the boundary.</li>
</ul>
<p>The default is 'cuboid'.</p>
</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>
<p>positions of the walls that define the bounding box of the coordinates.
The format must be given as <code>((zmin,zmax),(ymin,ymax),(xmin,xmax))</code>
when <code>handle_edge</code> is <code>'none'</code>, <code>'cuboid'</code> or <code>'periodic cuboid'</code>. When
<code>handle_edge='sphere'</code> the coordinates of the origin and radius of the
bouding sphere must be given as <code>(z,y,x,radius)</code>.</p>
<p>If all coordinate sets share the same boundary a single such boundary
can be given, otherwise a list of such array-likes of the same length
as coordinates can be given for specifying boundaries of each set in
<code>coordinates</code> separately. The default is <code>None</code> which determines the
smallest set of boundaries encompassing a set of coordinates.</p>
</dd>
<dt><strong><code>density</code></strong> :&ensp;<code>float</code> or <code>callable</code> or <code>list</code> of <code>callable</code>, optional</dt>
<dd>number density of particles in the box to use for normalizing the
values. The default is the average density based on <code>coordinates</code> and
<code>boundary</code>. When using custom edge correction in <code>handle_edge</code> it is
possible to instead pass a (list of) callable that takes the number of
particles and boundary and returns the number density.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, no output is printed to the terminal by this function call.
The default is False.</dd>
<dt><strong><code>neighbors_upper_bound</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>upper limit on the number of neighbors expected within rmax from a
particle. Useful for reducing memory consumption in datasets with
dimensions much larger than rmax. The default is None, which takes the
total number of particles in the coordinate set as upper limit.</dd>
<dt><strong><code>workers</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of workers to use for parallel processing during the neighbour
detection step. If -1 is given all CPU threads are used. Note: this is
ignored when <code>handle_edge='periodic cuboid'</code>. The default is 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rvals</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>bin-edges of the radial distribution function.</dd>
<dt><strong><code>bincounts</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>values for the bins of the radial distribution function</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Kopera, B. A. F., &amp; Retsch, M. (2018). Computing the 3D Radial
Distribution Function from Particle Positions: An Advanced Analytic
Approach. Analytical Chemistry, 90(23), 13909–13914.
<a href="https://doi.org/10.1021/acs.analchem.8b03157">https://doi.org/10.1021/acs.analchem.8b03157</a></p>
<p>[2] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
periodic boundary conditions.
<a href="https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf">https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf</a></p></div>
</dd>
<dt id="potentials_from_particle_insertion.rdf_insertion_binned_2d"><code class="name flex">
<span>def <span class="ident">rdf_insertion_binned_2d</span></span>(<span>coordinates,<br>pairpotential,<br>rmin=0,<br>rmax=10,<br>dr=None,<br>handle_edge='rectangle',<br>boundary=None,<br>pairpotential_binedges=None,<br>n_ins=1000,<br>interpolate=True,<br>avoid_boundary=False,<br>avoid_coordinates=False,<br>neighbors_upper_bound=None,<br>workers=1,<br>testparticle_func=None,<br>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate g(r) from insertion of test-particles into sets of existing
2D coordinates, averaged over bins of width dr, and based on the pairwise
interaction potential u(r) (in units of kT).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>numpy.array</code> or <code>list-like</code> of <code>numpy.array</code></dt>
<dd>list of sets of coordinates, where each item along the 0th dimension is
a N*2 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one TEM image, a time step from a
video, etc.), with each element of the array of form
<code>[y,x]</code>. Each
set of coordinates is not required to have the same number of particles
but must have the same particle density. When no boundaries or a single
boundary is given, it is assumed all coordinate sets share these same
boundaries.</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>iterable</code></dt>
<dd>list of values for the pairwise interaction potential. Must have length
of <code>len(pairpotential_binedges)-1</code> and be in units of thermal energy kT</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower bound for the pairwise distance, left edge of 0th bin. The
default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>upper bound for the pairwise distance, right edge of last bin. The
default is 10.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>bin width for the pairwise distance bins. The default is (rmax-rmin)/20</dd>
<dt><strong><code>handle_edge</code></strong> :&ensp;<code>one</code> of <code>['none','rectangle','periodic rectangle','circle', (list of) callable]</code>, optional</dt>
<dd>
<p>specifies how to correct for edge effects in the radial distribution
function. These edge effects occur due to particles closer than <code>rmax</code>
to any of the boundaries missing part of their neighbour shells in the
dataset. The following options for correcting for this are available:</p>
<ul>
<li><code>'rectangle'</code>: correct for the missing volume in a square or
rectangular boundary.</li>
<li><code>'periodic' rectangle'</code>: like <code>'rectangle'</code>, except in periodic
boundary conditions (i.e. one side wraps around to the other),
based on ref [1].</li>
<li><code>'circle'</code>: correct for missing volume in a spherical boundary.</li>
<li>a custom callable function (or list thereof) can be given to
correct for arbitrary and/or mixed boundary conditions. This
function must take three arguments: a numpy array of bin edges, an
N×2 numpy array of coordinates and a boundary as specified in
<code>boundary</code>, and return an N × <code>len(bin edges)-1</code> numpy array with
a value between 0 and 1 specifying the fraction of the volume of
each spherical shell that is within the boundary.</li>
</ul>
<p>The default is 'rectangle'.</p>
</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array-like</code> or <code>list</code> of <code>such</code>, optional</dt>
<dd>
<p>positions of the walls that define the bounding box of the coordinates.
The format must be given as <code>((ymin,ymax),(xmin,xmax))</code> when
<code>handle_edge</code> is <code>`'rectangle'</code> or <code>'periodic rectangle'</code>.
When <code>handle_edge='circle'</code> the coordinates of the origin and radius of
the bouding circle must be given as <code>(y,x,radius)</code>. For custom boundary
handling, <code>boundary</code> can be any format as required by the edge
edge correction function(s) passed to <code>handle_edge</code>.</p>
<p>If all coordinate sets share the same boundary, a single such boundary
can be given, otherwise a list of such array-likes of the same length
as coordinates can be given for specifying boundaries of each set in
<code>coordinates</code> separately. The default is <code>None</code> which determines the
smallest set of boundaries encompassing a set of coordinates.</p>
</dd>
<dt><strong><code>pairpotential_binedges</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>bin edges corresponding to the values in <code>pairpotential</code>. The default
is None, which uses the bins defined by <code>rmin</code>, <code>rmax</code> and <code>dr</code>.</dd>
<dt><strong><code>n_ins</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of test-particles to insert into each item in <code>coordinates</code>.
The default is 1000.</dd>
<dt><strong><code>interpolate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to use linear interpolation for calculating the interaction of
two particles using the values in <code>pairpotential</code>. The default is True.
If False, the nearest bin value is used.</dd>
<dt><strong><code>avoid_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, all test-particles are inserted at least <code>rmax</code> away from any
of the surfaces defined in <code>boundary</code> to avoid effects of the finite
volume of the bounding box. The default is False, which uses an
analytical correction factor for missing volume of test-particles near
the boundaries. This parameter is ignored when using custom edge
handling.</dd>
<dt><strong><code>avoid_coordinates</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to insert test-particles at least <code>rmin</code> away from the center
of any of the 'real' coordinates in <code>coordinates</code>. The default is
False.</dd>
<dt><strong><code>neighbors_upper_bound</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>upper limit on the number of neighbors expected within rmax from a
particle. Useful for reducing memory consumption in datasets with
dimensions much larger than rmax. The default is None, which takes the
total number of particles in the coordinate set as upper limit.</dd>
<dt><strong><code>workers</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of workers to use for parallel processing during the neighbour
detection step. If -1 is given all CPU threads are used. Note: this is
ignored when <code>handle_edge='periodic rectangle'</code>. The default is 1.</dd>
<dt><strong><code>testparticle_func</code></strong> :&ensp;<code>callable</code> or <code>list thereof</code></dt>
<dd>function that generates test-particle coordinates in the bounding box,
required when using custom edge handling (and ignored otherwise). When
<code>avoid_coordinates=True</code> this function must take 4 arguments: a
boundary as given in <code>boundary</code>, a N×2 numpy.array of coordinates to
avoid, a float specifing the radius around the coordinates to avoid,
and an integer giving the number of coordinates to generate. Otherwise,
it must only take the boundary and the number of coordinates to
generate as arguments. It must return an <code>n_ins</code> × 2 numpy array of
coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rvals</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>bin-edges of the radial distribution function.</dd>
<dt><strong><code>pair_correlation</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>values for the rdf / pair correlation function in each bin</dd>
<dt><strong><code>counter</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>number of pair counts that contributed to the (mean) values in each bin</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
periodic boundary conditions.
<a href="https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf">https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf</a></p></div>
</dd>
<dt id="potentials_from_particle_insertion.rdf_insertion_binned_3d"><code class="name flex">
<span>def <span class="ident">rdf_insertion_binned_3d</span></span>(<span>coordinates,<br>pairpotential,<br>rmin=0,<br>rmax=10,<br>dr=None,<br>handle_edge='cuboid',<br>boundary=None,<br>pairpotential_binedges=None,<br>n_ins=1000,<br>interpolate=True,<br>avoid_boundary=False,<br>avoid_coordinates=False,<br>neighbors_upper_bound=None,<br>workers=1,<br>testparticle_func=None,<br>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate g(r) from insertion of test-particles into sets of existing
2D coordinates, averaged over bins of width dr, and based on the pairwise
interaction potential u(r) (in units of kT).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>numpy.array</code> or <code>list-like</code> of <code>numpy.array</code></dt>
<dd>list of sets of coordinates, where each item along the 0th dimension is
a N*3 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one z-stack, a time step from a
video, etc.), with each element of the array of form
<code>[z,y,x]</code>. Each
set of coordinates is not required to have the same number of particles
but must have the same particle density. When no boundaries or a single
boundary is given, it is assumed all coordinate sets share these same
boundaries.</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>iterable</code></dt>
<dd>list of values for the pairwise interaction potential. Must have length
of <code>len(pairpotential_binedges)-1</code> and be in units of thermal energy kT</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower bound for the pairwise distance, left edge of 0th bin. The
default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>upper bound for the pairwise distance, right edge of last bin. The
default is 10.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>bin width for the pairwise distance bins. The default is (rmax-rmin)/20</dd>
<dt><strong><code>handle_edge</code></strong> :&ensp;<code>one</code> of <code>['none','cuboid','periodic cuboid','sphere', (list of) callable]</code>, optional</dt>
<dd>
<p>specifies how to correct for edge effects in the radial distribution
function. These edge effects occur due to particles closer than <code>rmax</code>
to any of the boundaries missing part of their neighbour shells in the
dataset. The following options for correcting for this are available:</p>
<ul>
<li><code>'none'</code> or <code>None</code> or <code>False</code> (all equivalent): do not correct
for edge effects at all. Note that in order to calculate the
particle density, cuboidal boundaries are assumed even when
<code>boundary</code> is not specified. This can be overridden by explicitely
giving the particle density using <code>density</code>.</li>
<li><code>'cuboid'</code>: correct for the missing volume in cuboidal boundary
conditions, e.g. a 3D rectangular box with right angles. Based on
ref. [1]</li>
<li><code>'periodic' cuboid'</code>: like <code>'cuboid'</code>, except in periodic
boundary conditions (i.e. one side wraps around to the other).
Based on ref. [2].</li>
<li><code>'sphere'</code>: correct for missing volume in spherical boundary
conditions</li>
<li>a custom callable function (or list thereof) can be given to
correct for arbitrary and/or mixed boundary conditions. This
function must take three arguments: a numpy array of bin edges, an
N×3 numpy array of coordinates and a boundary as specified in
<code>boundary</code>, and return an N × <code>len(bin edges)-1</code> numpy array with
a value between 0 and 1 specifying the fraction of the volume of
each spherical shell that is within the boundary.</li>
</ul>
<p>The default is 'cuboid'.</p>
</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>
<p>positions of the walls that define the bounding box of the coordinates.
The format must be given as <code>((zmin,zmax),(ymin,ymax),(xmin,xmax))</code>
when <code>handle_edge</code> is <code>'none'</code>, <code>'cuboid'</code> or <code>'periodic cuboid'</code>. When
<code>handle_edge='sphere'</code> the coordinates of the origin and radius of the
bouding sphere must be given as <code>(z,y,x,radius)</code>.</p>
<p>If all coordinate sets share the same boundary a single such boundary
can be given, otherwise a list of such array-likes of the same length
as coordinates can be given for specifying boundaries of each set in
<code>coordinates</code> separately. The default is <code>None</code> which determines the
smallest set of boundaries encompassing a set of coordinates.</p>
</dd>
<dt><strong><code>pairpotential_binedges</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>bin edges corresponding to the values in <code>pairpotential</code>. The default
is None, which uses the bins defined by <code>rmin</code>, <code>rmax</code> and <code>dr</code>.</dd>
<dt><strong><code>n_ins</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of test-particles to insert into each item in <code>coordinates</code>.
The default is 1000.</dd>
<dt><strong><code>interpolate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to use linear interpolation for calculating the interaction of
two particles using the values in <code>pairpotential</code>. The default is True.
If False, the nearest bin value is used.</dd>
<dt><strong><code>avoid_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, all test-particles are inserted at least <code>rmax</code> away from any
of the surfaces defined in <code>boundary</code> to avoid effects of the finite
volume of the bounding box. The default is False, which uses an
analytical correction factor for missing volume of test-particles near
the boundaries. This parameter is ignored when using custom edge
handling.</dd>
<dt><strong><code>avoid_coordinates</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to insert test-particles at least <code>rmin</code> away from the center
of any of the 'real' coordinates in <code>coordinates</code>. The default is
False.</dd>
<dt><strong><code>neighbors_upper_bound</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>upper limit on the number of neighbors expected within rmax from a
particle. Useful for reducing memory consumption in datasets with
dimensions much larger than rmax. The default is None, which takes the
total number of particles in the coordinate set as upper limit.</dd>
<dt><strong><code>workers</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of workers to use for parallel processing during the neighbour
detection step. If -1 is given all CPU threads are used. Note: this is
ignored when <code>handle_edge='periodic rectangle'</code>. The default is 1.</dd>
<dt><strong><code>testparticle_func</code></strong> :&ensp;<code>callable</code> or <code>list thereof</code></dt>
<dd>function that generates test-particle coordinates in the bounding box,
required when using custom edge handling (and ignored otherwise). When
<code>avoid_coordinates=True</code> this function must take 4 arguments: a
boundary as given in <code>boundary</code>, a N×3 numpy.array of coordinates to
avoid, a float specifing the radius around the coordinates to avoid,
and an integer giving the number of coordinates to generate. Otherwise,
it must only take the boundary and the number of coordinates to
generate as arguments. It must return an <code>n_ins</code>×3 numpy array of
coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rvals</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>bin-edges of the radial distribution function.</dd>
<dt><strong><code>pair_correlation</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>values for the rdf / pair correlation function in each bin</dd>
<dt><strong><code>counter</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>number of pair counts that contributed to the (mean) values in each bin</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Kopera, B. A. F., &amp; Retsch, M. (2018). Computing the 3D Radial
Distribution Function from Particle Positions: An Advanced Analytic
Approach. Analytical Chemistry, 90(23), 13909–13914.
<a href="https://doi.org/10.1021/acs.analchem.8b03157">https://doi.org/10.1021/acs.analchem.8b03157</a></p>
<p>[2] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
periodic boundary conditions.
<a href="https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf">https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf</a></p></div>
</dd>
<dt id="potentials_from_particle_insertion.rdf_insertion_exact_3d"><code class="name flex">
<span>def <span class="ident">rdf_insertion_exact_3d</span></span>(<span>coordinates,<br>pairpotential,<br>rmax,<br>dr,<br>boundary,<br>pairpotential_binedges=None,<br>gen_prob_reps=1000,<br>shell_prob_reps=10,<br>interpolate=True,<br>use_numba=True,<br>rmin=0)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function underwent very minimal testing and is computationally
inefficient. Use at your own risk.</p>
</div>
<p>calculate g(r) from particle insertion method using particle coordinates
and pairwise interaction potential u(r) (in units of kT). Inserts test-
particles at a specific r for every real particle. Implementation based on
ref [1]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list</code> of <code>numpy.array</code> of <code>floats</code> of <code>shape nt*n*3</code></dt>
<dd>The coordinates of particles in the system</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>list</code> of <code>floats</code></dt>
<dd>the value of the interparticle potential in each bin of 0 to rmax+dr
in steps of dr. The value is assumed to correspond to the centrepoint
of the bins.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>cut-off value for the radius. Interactions beyond this range are
considered negligable. Right edge of last bin in the pair potential</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code></dt>
<dd>bin width/step size of the interparticle distance used for g(r) and the
pair potential.</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>tuple</code> of <code>floats</code> of <code>form ((zmin,zmax),(ymin,ymax),(xmin,xmax))</code></dt>
<dd>defines the boundaries of the box in which coordinates may exist.</dd>
<dt><strong><code>gen_prob_reps</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of trial particles used to evaluate the general probability of
placing a particle at random coordinates in the box defined by
<code>boundary</code>. The default is 1000.</dd>
<dt><strong><code>shell_prob_reps</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of trial particles per reference coordinate in <code>coordinates</code>
used to evaluate the probability of placing a particle in each distance
bin. The default is 10.</dd>
<dt><strong><code>interpolate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, the pair potential is linearly interpolated between bin
centres to calculate the interactions between all pairs of particles.
If false, the value from the nearest bin is taken which is
slower to compute. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pair_correlation</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>the pair correlation / radial distribution functions evaluated in the
bins whose edges are defined by numpy.arange(0,rmax+dr,dr)</dd>
<dt><strong><code>counters</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>The number of trialparticles evaluated for each distance bin</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2018). Contact
values of pair distribution functions in colloidal hard disks by
test-particle insertion. The Journal of Chemical Physics, 148(24), 241102.
<a href="https://doi.org/10.1063/1.5038668">https://doi.org/10.1063/1.5038668</a></p></div>
</dd>
<dt id="potentials_from_particle_insertion.run_iteration"><code class="name flex">
<span>def <span class="ident">run_iteration</span></span>(<span>coordinates,<br>pair_correlation_func,<br>initial_guess=None,<br>rmin=0,<br>rmax=10,<br>dr=None,<br>convergence_tol=1e-05,<br>max_iterations=100,<br>zero_clip=1e-20,<br>regulate=False,<br>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the algorithm to solve for the pairwise potential that most
accurately reproduces the radial distribution function using test-particle
insertion, based on the ideas in ref. [1].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list-like</code> of <code>numpy.array</code></dt>
<dd>List of sets of coordinates, where each item along the 0th dimension is
a n*3 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one z-stack, a time step from a
video, etc.), with each element of the array of form
<code>[z,y,x]</code> or
<code>[y,x]</code> in case of 2D data. Each set of coordinates is not required to
have the same number of particles but all stacks must share the same
bounding box as given by <code>boundary</code>, and all coordinates must be within
this bounding box.</dd>
<dt><strong><code>pair_correlation_func</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>bin values for the true pair correlation function that the algorithm
will try to match iteratively.</dd>
<dt><strong><code>initial_guess</code></strong> :&ensp;<code>list</code> of <code>float</code>, optional</dt>
<dd>Initial guess for the particle potential on the 0th iteration. The
default is None which gives 0 in each bin.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>left edge of the smallest bin in interparticle distance r to consider.
The default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Right edge of the largest bin in interparticle distance r to consider.
The default is 20.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Stepsize or bin width in interparticle distance r. The default is 0.5.</dd>
<dt><strong><code>convergence_tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>target value for χ², if it dips below this value the iteration is
considered to be converged and ended. The default is <code>1e-5</code>.</dd>
<dt><strong><code>max_iterations</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of iterations after which the algorithm is ended. The
default is 100.</dd>
<dt><strong><code>zero_clip</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>values below the value of zero-clip are set to this value to avoid
devision by zero errors. The default is <code>1e-20</code>.</dd>
<dt><strong><code>regulate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, use regularization to more gently nudge towards the input g(r)
at the cost of slower convergence. Experimental option. The default is
<code>False</code>.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>key=value</code></dt>
<dd>Additional keyword arguments are passed on to <code><a title="potentials_from_particle_insertion.rdf_insertion_binned_2d" href="#potentials_from_particle_insertion.rdf_insertion_binned_2d">rdf_insertion_binned_2d()</a></code>
or <code><a title="potentials_from_particle_insertion.rdf_insertion_binned_3d" href="#potentials_from_particle_insertion.rdf_insertion_binned_3d">rdf_insertion_binned_3d()</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>χ²</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>summed squared error in the pair correlation function for each
iteration</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>the values for the pair potential in each bin for each iteration</dd>
<dt><strong><code>paircorrelation</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>the values for the pair correlation function from test-particle
insertion for each iteration</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>int</code></dt>
<dd>number of pair counts contributing to each bin in each iteration</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2019). Model-
Free Measurement of the Pair Potential in Colloidal Fluids Using Optical
Microscopy. Physical Review Letters, 123(9), 098002.
<a href="https://doi.org/10.1103/PhysRevLett.123.098002">https://doi.org/10.1103/PhysRevLett.123.098002</a></p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="potentials_from_particle_insertion.rdf_insertion_binned_2d" href="#potentials_from_particle_insertion.rdf_insertion_binned_2d">rdf_insertion_binned_2d()</a></code></dt>
<dd>2D routine for g(r) from test-particle insertion</dd>
<dt><code><a title="potentials_from_particle_insertion.rdf_insertion_binned_3d" href="#potentials_from_particle_insertion.rdf_insertion_binned_3d">rdf_insertion_binned_3d()</a></code></dt>
<dd>3D routine for g(r) from test-particle insertion</dd>
</dl></div>
</dd>
<dt id="potentials_from_particle_insertion.run_iterator_fitfunction"><code class="name flex">
<span>def <span class="ident">run_iterator_fitfunction</span></span>(<span>coordinates,<br>pair_correlation_func,<br>potential_func,<br>initial_guess=None,<br>fit_bounds=None,<br>rmin=0,<br>rmax=20,<br>dr=None,<br>convergence_tol=1e-05,<br>max_iterations=100,<br>max_func_evals=100,<br>zero_clip=1e-20,<br>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the algorithm to solve for the pairwise potential that most
accurately reproduces the radial distribution function using test-particle
insertion, using a fit function of known form instead of a generalized
binned potential based on scipy.optimize.curve_fit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list-like</code> of <code>numpy.array</code></dt>
<dd>List of sets of coordinates, where each item along the 0th dimension is
a n*3 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one z-stack, a time step from a
video, etc.), with each element of the array of form
<code>[z,y,x]</code> or
<code>[y,x]</code> in case of 2D data. Each set of coordinates is not required to
have the same number of particles but all stacks must share the same
bounding box as given by <code>boundary</code>, and all coordinates must be within
this bounding box.</dd>
<dt><strong><code>pair_correlation_func</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>bin values for the true pair correlation function that the algorithm
will try to match iteratively.</dd>
<dt><strong><code>potential_func</code></strong> :&ensp;<code>callable</code></dt>
<dd>fit funtion to use, where the first argument is the interparticle
distance r, and any subsequent arguments are optimized for.</dd>
<dt><strong><code>initial_guess</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>values for the function parameters to use for the first iteration.
The default is None.</dd>
<dt><strong><code>fit_bounds</code></strong> :&ensp;<code>2-tuple</code> of <code>list_like</code>, optional</dt>
<dd>Each element of the tuple must be either an array with the length equal
to the number of parameters, or a scalar (in which case the bound is
taken to be the same for all parameters). Use np.inf with an
appropriate sign to disable bounds on all or some parameters.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>left edge of the smallest bin in interparticle distance r to consider.
The default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Right edge of the largest bin in interparticle distance r to consider.
The default is 20.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Stepsize or bin width in interparticle distance r. The default is 0.5.</dd>
<dt><strong><code>convergence_tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>target value for χ², if it dips below this value the iteration is
considered to be converged and ended. The default is <code>1e-5</code>.</dd>
<dt><strong><code>max_iterations</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of iterations after which the algorithm is ended. The
default is 100.</dd>
<dt><strong><code>max_func_evals</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of times the TPI function is evaluated. The default is
100.</dd>
<dt><strong><code>zero_clip</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>values below the value of zero-clip are set to this value to avoid
devision by zero errors. The default is <code>1e-20</code>.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>key=value</code></dt>
<dd>Additional keyword arguments are passed on to <code><a title="potentials_from_particle_insertion.rdf_insertion_binned_2d" href="#potentials_from_particle_insertion.rdf_insertion_binned_2d">rdf_insertion_binned_2d()</a></code>
or <code><a title="potentials_from_particle_insertion.rdf_insertion_binned_3d" href="#potentials_from_particle_insertion.rdf_insertion_binned_3d">rdf_insertion_binned_3d()</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>χ²</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>summed squared error in the pair correlation function for each
iteration</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>list</code> of <code>callable</code></dt>
<dd>potential functions giving the potential for each iteraction</dd>
<dt><strong><code>fit_params</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>the values for the function parameters in each iteration</dd>
<dt><strong><code>paircorrelation</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>the values for the pair correlation function from test-particle
insertion for each iteration</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>int</code></dt>
<dd>number of pair counts contributing to each bin in each iteration</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="potentials_from_particle_insertion.rdf_insertion_binned_2d" href="#potentials_from_particle_insertion.rdf_insertion_binned_2d">rdf_insertion_binned_2d()</a></code></dt>
<dd>2D routine for g(r) from test-particle insertion</dd>
<dt><code><a title="potentials_from_particle_insertion.rdf_insertion_binned_3d" href="#potentials_from_particle_insertion.rdf_insertion_binned_3d">rdf_insertion_binned_3d()</a></code></dt>
<dd>3D routine for g(r) from test-particle insertion</dd>
</dl></div>
</dd>
<dt id="potentials_from_particle_insertion.save_TPI_results"><code class="name flex">
<span>def <span class="ident">save_TPI_results</span></span>(<span>rmin,<br>rmax,<br>dr,<br>bincentres,<br>dhrdf,<br>rdfs,<br>potentials,<br>counts,<br>errors,<br>filename='particle_insertion_result.txt')</span>
</code></dt>
<dd>
<div class="desc"><p>utility function for saving results from TPI as txt file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code></dt>
<dd>lower bound on interparticle distance</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>upper bound on interparticle distance</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code></dt>
<dd>bin width of interparticle distance</dd>
<dt><strong><code>bincentres</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>centre position of each interparticle distance bin</dd>
<dt><strong><code>dhrdf</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>g(r) values from DH calculation for each bin</dd>
<dt><strong><code>rdfs</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>g(r) values from TPI for each bin for each iteration</dd>
<dt><strong><code>potentials</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>u(r) values for each bin for each iteration</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>bin counts for each bin for each iteration</dd>
<dt><strong><code>errors</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>chi squared error for each iteration</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename to use. The default is 'particle_insertion_result.txt'.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#description">Description</a></li>
<li><a href="#references">References</a></li>
<li><a href="#license">License</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="potentials_from_particle_insertion.multicomponent" href="multicomponent/index.html">potentials_from_particle_insertion.multicomponent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="potentials_from_particle_insertion.load_TPI_results" href="#potentials_from_particle_insertion.load_TPI_results">load_TPI_results</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_dist_hist_2d" href="#potentials_from_particle_insertion.rdf_dist_hist_2d">rdf_dist_hist_2d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_dist_hist_3d" href="#potentials_from_particle_insertion.rdf_dist_hist_3d">rdf_dist_hist_3d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_insertion_binned_2d" href="#potentials_from_particle_insertion.rdf_insertion_binned_2d">rdf_insertion_binned_2d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_insertion_binned_3d" href="#potentials_from_particle_insertion.rdf_insertion_binned_3d">rdf_insertion_binned_3d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_insertion_exact_3d" href="#potentials_from_particle_insertion.rdf_insertion_exact_3d">rdf_insertion_exact_3d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.run_iteration" href="#potentials_from_particle_insertion.run_iteration">run_iteration</a></code></li>
<li><code><a title="potentials_from_particle_insertion.run_iterator_fitfunction" href="#potentials_from_particle_insertion.run_iterator_fitfunction">run_iterator_fitfunction</a></code></li>
<li><code><a title="potentials_from_particle_insertion.save_TPI_results" href="#potentials_from_particle_insertion.save_TPI_results">save_TPI_results</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
