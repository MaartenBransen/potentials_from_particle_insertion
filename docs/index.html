<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>potentials_from_particle_insertion API documentation</title>
<meta name="description" content="Maarten Bransen, 2020
m.bransen@uu.nl" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>potentials_from_particle_insertion</code></h1>
</header>
<section id="section-intro">
<p>Maarten Bransen, 2020
m.bransen@uu.nl</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Maarten Bransen, 2020
m.bransen@uu.nl
&#34;&#34;&#34;

__version__ = &#39;0.2&#39;

from .pairpotential_iterator import run_iteration
from .distribution_functions import rdf_insertion_binned_3d,rdf_insertion_exact_3d,\
    rdf_dist_hist_3d,rdf_insertion_binned_2d,rdf_dist_hist_2d

#define all for doing `from .. import *`
__all__ = [
    &#39;run_iteration&#39;,
    &#39;rdf_insertion_binned_2d&#39;,
    &#39;rdf_insertion_binned_3d&#39;,
    &#39;rdf_insertion_exact_3d&#39;,
    &#39;rdf_dist_hist_2d&#39;,
    &#39;rdf_dist_hist_3d&#39;,
]

#add submodules to pdoc ignore list for generated documentation
__pdoc__ = {
    &#39;pairpotential_iterator&#39; : False,
    &#39;distribution_functions&#39; : False,
    &#39;geometry&#39; : False,
    &#39;generate_coordinates&#39; : False
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="potentials_from_particle_insertion.rdf_dist_hist_2d"><code class="name flex">
<span>def <span class="ident">rdf_dist_hist_2d</span></span>(<span>coordinates, rmin=0, rmax=10, dr=None, boundary=None, density=None, periodic_boundary=False, handle_edge=True, quiet=False)</span>
</code></dt>
<dd>
<section class="desc"><p>calculates g(r) via a 'conventional' distance histogram method for a
set of 2D coordinate sets. Provided for convenience. Edge correction based
on refs [1] and [2].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>numpy.array</code> or <code>list</code>-<code>like</code> of <code>numpy.array</code> of <code>floats</code></dt>
<dd>list of sets of coordinates, where each item along the 0th dimension is
a n*3 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one z-stack, a time step from a
video, etc.), with each element of the array of form
<code>[z,y,x]</code>. Each
set of coordinates is not required to have the same number of particles
but all stacks must share the same
bounding box as given by
<code>boundary</code>, and all coordinates must be within this bounding box.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower bound for the pairwise distance, left edge of 0th bin. The
default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>upper bound for the pairwise distance, right edge of last bin. The
default is 10.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>bin width for the pairwise distance bins. The default is (rmax-rmin)/20</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array</code>-<code>like</code>, optional</dt>
<dd>positions of the walls that define the bounding box of the coordinates,
given as
<code>((zmin,zmax),(ymin,ymax),(xmin,xmax))</code>. The default is the
min and max values in the dataset along each dimension.</dd>
<dt><strong><code>density</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>number density of particles in the box to use for normalizing the
values. The default is the average density based on <code>coordinates</code> and
<code>boundary</code>.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether periodic boundary conditions are used. The default is False.</dd>
<dt><strong><code>handle_edge</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to correct for edge effects in non-periodic boundary
conditions. The default is True.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, no output is printed to the terminal by this function call.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rvals</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>bin-edges of the radial distribution function.</dd>
<dt><strong><code>bincounts</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>values for the bins of the radial distribution function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rdf_dist_hist_2d(coordinates,rmin=0,rmax=10,dr=None,boundary=None,
                     density=None,periodic_boundary=False,handle_edge=True,
                     quiet=False):
    &#34;&#34;&#34;calculates g(r) via a &#39;conventional&#39; distance histogram method for a 
    set of 2D coordinate sets. Provided for convenience. Edge correction based
    on refs [1] and [2].

    Parameters
    ----------
    coordinates : numpy.array or list-like of numpy.array of floats
        list of sets of coordinates, where each item along the 0th dimension is
        a n*3 numpy.array of particle coordinates, where each array is an 
        independent set of coordinates (e.g. one z-stack, a time step from a 
        video, etc.), with each element of the array of form  `[z,y,x]`. Each 
        set of coordinates is not required to have the same number of particles
        but all stacks must share the same  bounding box as given by 
        `boundary`, and all coordinates must be within this bounding box.
    rmin : float, optional
        lower bound for the pairwise distance, left edge of 0th bin. The 
        default is 0.
    rmax : float, optional
        upper bound for the pairwise distance, right edge of last bin. The 
        default is 10.
    dr : float, optional
        bin width for the pairwise distance bins. The default is (rmax-rmin)/20
    boundary : array-like, optional
        positions of the walls that define the bounding box of the coordinates,
        given as  `((zmin,zmax),(ymin,ymax),(xmin,xmax))`. The default is the 
        min and max values in the dataset along each dimension.
    density : float, optional
        number density of particles in the box to use for normalizing the 
        values. The default is the average density based on `coordinates` and
        `boundary`.
    periodic_boundary : bool, optional
        whether periodic boundary conditions are used. The default is False.
    handle_edge : bool, optional
        whether to correct for edge effects in non-periodic boundary 
        conditions. The default is True.
    quiet : bool, optional
        if True, no output is printed to the terminal by this function call. 
        The default is False.

    Returns
    -------
    rvals : numpy.array
        bin-edges of the radial distribution function.
    bincounts : numpy.array
        values for the bins of the radial distribution function
        
    &#34;&#34;&#34;
    #create bins
    rvals = np.arange(rmin,rmax+dr,dr)
    
    #assure array of arrays with first axis as dtype=object and rest floats
    if type(coordinates)==list:#weird syntax but there&#39;s no prettier way
        coordinates = np.array([None]+coordinates,dtype=object)[1:]
    elif type(coordinates)==np.ndarray:
        if not np.can_cast(coordinates[0].dtype,float):
            raise TypeError(
                &#34;dtype `{}` of `coordinates` can&#39;t be broadcasted to `float`&#34;.format(coordinates[0].dtype)
            )
    else:
        raise TypeError(
            &#34;dtype `{}` of `coordinates` not supported, use a list of numpy.array&#34;.format(type(coordinates))
        )
    
    #check list of coordinates or only one coordinate set
    if coordinates.ndim == 2:
        coordinates = coordinates[np.newaxis,:,:]
    
    #set default step size
    if type(dr)==type(dr):
        dr = (rmax-rmin)/20
    
    #set default boundary as min and max values in dataset
    if type(boundary)==type(None):
        boundary = np.array([
                [coordinates[:,:,0].min(),coordinates[:,:,0].max()],
                [coordinates[:,:,1].min(),coordinates[:,:,1].max()]
            ])
    else:
        boundary = np.array(boundary)
    
    
    #check rmax and boundary for edge-handling in periodic boundary conditions
    if periodic_boundary:
        if boundary[0,1]-boundary[0,0] == boundary[1,1]-boundary[1,0]:
            boxlen = boundary[0,1]-boundary[0,0]
            if rmax &gt; boxlen*np.sqrt(2)/2:
                raise ValueError(
                    &#39;rmax cannot be more than sqrt(2)/2 times the size of a &#39;+
                    &#39;square bounding box when periodic_boundary=True, use &#39;+
                    &#39;rmax &lt; {:}&#39;.format((boundary[0,1]-boundary[0,0])*np.sqrt(2)/2)
                )
        elif rmax &gt; min(boundary[:,1]-boundary[:,0])/2:
            raise NotImplementedError(
                &#39;rmax larger than half the smallest box dimension when &#39;+
                &#39;periodic_boundary=True is only implemented for square boundaries&#39;
            )
    
    #check rmax and boundary for edge handling without periodic boundaries
    else:
        if rmax &gt; max(boundary[:,1]-boundary[:,0])/2:
            raise ValueError(
                &#39;rmax cannot be larger than half the largest dimension in &#39;+
                &#39;boundary, use rmax &lt; {:}&#39;.format(max(boundary[:,1]-boundary[:,0])/2)
            )
    
    #set density to mean number density in dataset
    if not density:
        vol = np.product(boundary[:,1]-boundary[:,0])
        density = np.mean([len(coords)/vol for coords in coordinates])
    
    
    #loop over all sets of coordinates
    bincounts = []
    for i,coords in enumerate(coordinates):
        
        #print progress
        if not quiet:
            print(&#39;\rcalculating distance histogram g(r) {:d} of {:d}&#39;.format(i+1,len(coordinates)),end=&#39;&#39;)
        
        #set up KDTree for fast neighbour finding
        #shift box boundary corner to origin for periodic KDTree
        if periodic_boundary:
            tree = cKDTree(coords-boundary[:,0],boxsize=boundary[:,1]-boundary[:,0])
        else:
            tree = cKDTree(coords)
        
        #query tree for any neighbours up to rmax
        dist,indices = tree.query(coords,k=len(coords),distance_upper_bound=rmax)
        
        #remove pairs with self, padded (infinite) values and anythin below rmin
        dist = dist[:,1:]
        mask = np.isfinite(dist) &amp; (dist&gt;=rmin)
        
        #when dealing with edges, histogram the distances per reference particle
        #and apply correction factor for missing volume
        if handle_edge:
            if periodic_boundary:
                boundarycorr = _circle_ring_area_frac_periodic(
                    rvals,
                    boundary[0,1]-boundary[0,0]
                )
                counts = np.histogram(dist[mask],bins=rvals)[0]/boundarycorr

            else:
                dist = np.ma.masked_array(dist,mask)
                counts = np.apply_along_axis(
                    lambda row: np.histogram(row.data[row.mask],bins=rvals)[0],
                    1,
                    dist
                    )
                boundarycorr=_circle_ring_area_fraction(
                    rvals,
                    boundary-coords[:,:,np.newaxis]
                    )
                counts = np.sum(counts/boundarycorr,axis=0)
        
        #otherwise just histogram as a 1d list of distances
        else:
            counts = np.histogram(dist[mask],bins=rvals)[0]
        
        #normalize and add to overall list
        bincounts.append(counts / (np.pi*(rvals[1:]**2 - rvals[:-1]**2)) / (density*len(coords)))
    
    #newline
    if not quiet:
        print()
    
    #average all datasets
    bincounts = np.mean(bincounts,axis=0)
    
    return rvals,bincounts</code></pre>
</details>
</dd>
<dt id="potentials_from_particle_insertion.rdf_dist_hist_3d"><code class="name flex">
<span>def <span class="ident">rdf_dist_hist_3d</span></span>(<span>coordinates, rmin=0, rmax=10, dr=None, boundary=None, density=None, periodic_boundary=False, handle_edge=True, quiet=False)</span>
</code></dt>
<dd>
<section class="desc"><p>calculates g(r) via a 'conventional' distance histogram method for a
set of 3D coordinate sets. Provided for convenience. Edge correction based
on refs [1] and [2].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>numpy.array</code> or <code>list</code>-<code>like</code> of <code>numpy.array</code></dt>
<dd>list of sets of coordinates, where each item along the 0th dimension is
a n*3 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one z-stack, a time step from a
video, etc.), with each element of the array of form
<code>[z,y,x]</code>. Each
set of coordinates is not required to have the same number of particles
but all stacks must share the same
bounding box as given by
<code>boundary</code>, and all coordinates must be within this bounding box.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower bound for the pairwise distance, left edge of 0th bin. The
default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>upper bound for the pairwise distance, right edge of last bin. The
default is 10.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>bin width for the pairwise distance bins. The default is (rmax-rmin)/20</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array</code>-<code>like</code>, optional</dt>
<dd>positions of the walls that define the bounding box of the coordinates,
given as
<code>((zmin,zmax),(ymin,ymax),(xmin,xmax))</code>. The default is the
min and max values in the dataset along each dimension.</dd>
<dt><strong><code>density</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>number density of particles in the box to use for normalizing the
values. The default is the average density based on <code>coordinates</code> and
<code>boundary</code>.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether periodic boundary conditions are used. The default is False.</dd>
<dt><strong><code>handle_edge</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to correct for edge effects in non-periodic boundary
conditions. The default is True.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, no output is printed to the terminal by this function call.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rvals</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>bin-edges of the radial distribution function.</dd>
<dt><strong><code>bincounts</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>values for the bins of the radial distribution function</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
periodic boundary conditions.
<a href="https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf">https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf</a></p>
<p>[2] Kopera, B. A. F., &amp; Retsch, M. (2018). Computing the 3D Radial
Distribution Function from Particle Positions: An Advanced Analytic
Approach. Analytical Chemistry, 90(23), 13909–13914.
<a href="https://doi.org/10.1021/acs.analchem.8b03157">https://doi.org/10.1021/acs.analchem.8b03157</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rdf_dist_hist_3d(coordinates,rmin=0,rmax=10,dr=None,boundary=None,
                     density=None,periodic_boundary=False,handle_edge=True,
                     quiet=False):
    &#34;&#34;&#34;calculates g(r) via a &#39;conventional&#39; distance histogram method for a 
    set of 3D coordinate sets. Provided for convenience. Edge correction based
    on refs [1] and [2].

    Parameters
    ----------
    coordinates : numpy.array or list-like of numpy.array
        list of sets of coordinates, where each item along the 0th dimension is
        a n*3 numpy.array of particle coordinates, where each array is an 
        independent set of coordinates (e.g. one z-stack, a time step from a 
        video, etc.), with each element of the array of form  `[z,y,x]`. Each 
        set of coordinates is not required to have the same number of particles
        but all stacks must share the same  bounding box as given by 
        `boundary`, and all coordinates must be within this bounding box.
    rmin : float, optional
        lower bound for the pairwise distance, left edge of 0th bin. The 
        default is 0.
    rmax : float, optional
        upper bound for the pairwise distance, right edge of last bin. The 
        default is 10.
    dr : float, optional
        bin width for the pairwise distance bins. The default is (rmax-rmin)/20
    boundary : array-like, optional
        positions of the walls that define the bounding box of the coordinates,
        given as  `((zmin,zmax),(ymin,ymax),(xmin,xmax))`. The default is the 
        min and max values in the dataset along each dimension.
    density : float, optional
        number density of particles in the box to use for normalizing the 
        values. The default is the average density based on `coordinates` and
        `boundary`.
    periodic_boundary : bool, optional
        whether periodic boundary conditions are used. The default is False.
    handle_edge : bool, optional
        whether to correct for edge effects in non-periodic boundary 
        conditions. The default is True.
    quiet : bool, optional
        if True, no output is printed to the terminal by this function call. 
        The default is False.

    Returns
    -------
    rvals : numpy.array
        bin-edges of the radial distribution function.
    bincounts : numpy.array
        values for the bins of the radial distribution function
    
    References
    ----------
    [1] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
    periodic boundary conditions.
    https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf
    
    [2] Kopera, B. A. F., &amp; Retsch, M. (2018). Computing the 3D Radial 
    Distribution Function from Particle Positions: An Advanced Analytic 
    Approach. Analytical Chemistry, 90(23), 13909–13914. 
    https://doi.org/10.1021/acs.analchem.8b03157
    &#34;&#34;&#34;
    
    #create bins
    rvals = np.arange(rmin,rmax+dr,dr)
    
    #assure array of arrays with first axis as dtype=object and rest floats
    if type(coordinates)==list:#weird syntax but there&#39;s no prettier way
        coordinates = np.array([None]+coordinates,dtype=object)[1:]
    
    elif type(coordinates)==np.ndarray:
        if not np.can_cast(coordinates[0].dtype,float):
            raise TypeError(
                &#34;dtype `{}` of `coordinates` can&#39;t be broadcasted to `float`&#34;.format(coordinates[0].dtype)
            )
    else:
        raise TypeError(
            &#34;dtype `{}` of `coordinates` not supported, use a list of numpy.array&#34;.format(type(coordinates))
        )
    
    #assure 3D array for coordinates
    if coordinates.ndim == 2:
        coordinates = coordinates[np.newaxis,:,:]
    
    #set default step size
    if type(dr)==type(dr):
        dr = (rmax-rmin)/20
    
    #set default boundary as min and max values in dataset
    if type(boundary)==type(None):
        boundary = np.array([
                [coordinates[:,:,0].min(),coordinates[:,:,0].max()],
                [coordinates[:,:,1].min(),coordinates[:,:,1].max()],
                [coordinates[:,:,2].min(),coordinates[:,:,2].max()]
            ])
    else:
        boundary = np.array(boundary)
    
    #check rmax and boundary for edge-handling in periodic boundary conditions
    if periodic_boundary:
        if min(boundary[:,1]-boundary[:,0])==max(boundary[:,1]-boundary[:,0]):
            boxlen = boundary[0,1]-boundary[0,0]
            if rmax &gt; boxlen*np.sqrt(3)/2:
                raise ValueError(
                    &#39;rmax cannot be more than sqrt(3)/2 times the size of a &#39;+
                    &#39;cubic bounding box when periodic_boundary=True, use &#39;+
                    &#39;rmax &lt; {:}&#39;.format((boundary[0,1]-boundary[0,0])*np.sqrt(3)/2)
                )
        elif rmax &gt; min(boundary[:,1]-boundary[:,0]):
            raise NotImplementedError(
                &#39;rmax larger than half the smallest box dimension when &#39;+
                &#39;periodic_boundary=True is only implemented for cubic boundaries&#39;
            )
    
    #check rmax and boundary for edge handling without periodic boundaries
    else:
        if rmax &gt; max(boundary[:,1]-boundary[:,0])/2:
            raise ValueError(
                &#39;rmax cannot be larger than half the largest dimension in &#39;+
                &#39;boundary, use rmax &lt; {:}&#39;.format(max(boundary[:,1]-boundary[:,0])/2)
            )
    
    #set density to mean number density in dataset
    if not density:
        vol = np.product(boundary[:,1]-boundary[:,0])
        density = np.mean([len(coords)/vol for coords in coordinates])
    
    
    #loop over all sets of coordinates
    bincounts = []
    for i,coords in enumerate(coordinates):
        
        #print progress
        if not quiet:
            print(&#39;\rcalculating distance histogram g(r) {:} of {:}&#39;.format(i+1,len(coordinates)),end=&#39;&#39;)
        
        #set up KDTree for fast neighbour finding
        #shift box boundary corner to origin for periodic KDTree
        if periodic_boundary:
            tree = cKDTree(coords-boundary[:,0],boxsize=boundary[:,1]-boundary[:,0])
        else:
            tree = cKDTree(coords)
        
        #query tree for any neighbours up to rmax
        dist,indices = tree.query(coords,k=len(coords),distance_upper_bound=rmax)
        
        #remove pairs with self, padded (infinite) values and anythin below rmin
        dist = dist[:,1:]
        mask = np.isfinite(dist) &amp; (dist&gt;=rmin)
        
        #when dealing with edges, histogram the distances per reference particle
        #and apply correction factor for missing volume
        if handle_edge:
            if periodic_boundary:
                boundarycorr = _sphere_shell_vol_frac_periodic(
                    rvals,
                    min(boundary[:,1]-boundary[:,0])
                )
                counts = np.histogram(dist[mask],bins=rvals)[0]/boundarycorr

            else:
                dist = np.ma.masked_array(dist,mask)
                counts = np.apply_along_axis(
                    lambda row: np.histogram(row.data[row.mask],bins=rvals)[0],
                    1,
                    dist
                    )
                boundarycorr=_sphere_shell_vol_fraction(
                    rvals,
                    boundary-coords[:,:,np.newaxis]
                    )
                counts = np.sum(counts/boundarycorr,axis=0)
        
        #otherwise just histogram as a 1d list of distances
        else:
            counts = np.histogram(dist[mask],bins=rvals)[0]
        
        #normalize and add to overall list
        bincounts.append(counts / (4/3*np.pi * (rvals[1:]**3 - rvals[:-1]**3)) / (density*len(coords)))
    
    #newline
    if not quiet:
        print()
    
    #average all datasets
    bincounts = np.mean(bincounts,axis=0)
    
    return rvals,bincounts</code></pre>
</details>
</dd>
<dt id="potentials_from_particle_insertion.rdf_insertion_binned_2d"><code class="name flex">
<span>def <span class="ident">rdf_insertion_binned_2d</span></span>(<span>coordinates, pairpotential, rmax, dr, boundary, pairpotential_binedges=None, n_ins=1000, interpolate=True, rmin=0, periodic_boundary=False, avoid_boundary=False, avoid_coordinates=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate g(r) from insertion of test-particles into sets of existing
2D coordinates, averaged over bins of width dr, and based on the pairwise
interaction potential u(r) (in units of kT).</p>
<p>Implementation partly based on ref. [1] but with novel corrections for
edge effects based on analytical formulas for periodic and nonperiodic
boundary conditions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list</code>-<code>like</code> of <code>numpy.array</code></dt>
<dd>List of sets of coordinates, where each item along the 0th dimension is
a n*2 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one time step from a video, etc.),
with each element of the array of form
<code>[y,x]</code>. Each
set of
coordinates is not required to have the same number of particles but
all stacks must share the same
bounding box as given by
<code>boundary</code>,
and all coordinates must be within this bounding box.</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>iterable</code></dt>
<dd>list of values for the pairwise interaction potential. Must have length
of <code>len(pairpotential_binedges)-1</code> and be in units of thermal energy kT</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>cut-off radius for the pairwise distance (right edge of last bin).</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code></dt>
<dd>bin width of the pairwise distance bins.</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array</code>-<code>like</code> of <code>form</code> <code>((</code>ymin<code>,</code>ymax<code>),(</code>xmin<code>,</code>xmax<code>))</code></dt>
<dd>positions of the walls that define the bounding box of the coordinates.</dd>
<dt><strong><code>pairpotential_binedges</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>bin edges corresponding to the values in <code>pairpotential. The default
is None, which uses the bins defined by</code>rmin<code>,</code>rmax<code>and</code>dr`.</dd>
<dt><strong><code>n_ins</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of test-particles to insert into each item in <code>coordinates</code>.
The default is 1000.</dd>
<dt><strong><code>interpolate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to use linear interpolation for calculating the interaction of
two particles using the values in <code>pairpotential</code>. The default is True.
If False, the nearest bin value is used.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower cut-off for the pairwise distance. The default is 0.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether periodic boundary conditions are used. The default is False.</dd>
<dt><strong><code>avoid_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, all test-particles are inserted at least <code>rmax</code> away from any
of the surfaces defined in <code>boundary</code> to avoid effects of the finite
volume of the bounding box. The default is False, which uses an
analytical correction factor for missing volume of test-particles near
the boundaries.</dd>
<dt><strong><code>avoid_coordinates</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to insert test-particles at least <code>rmin</code> away from the center
of any of the 'real' coordinates in <code>coordinates</code>. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pair_correlation</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>values for the rdf / pair correlation function in each bin</dd>
<dt><strong><code>counter</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>number of pair counts that contributed to the (mean) values in each bin</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2019). Model-
Free Measurement of the Pair Potential in Colloidal Fluids Using Optical
Microscopy. Physical Review Letters, 123(9), 098002.
<a href="https://doi.org/10.1103/PhysRevLett.123.098002">https://doi.org/10.1103/PhysRevLett.123.098002</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rdf_insertion_binned_2d(coordinates,pairpotential,rmax,dr,boundary,
                            pairpotential_binedges=None,n_ins=1000,
                            interpolate=True,rmin=0,periodic_boundary=False,
                            avoid_boundary=False,avoid_coordinates=False):
    &#34;&#34;&#34;Calculate g(r) from insertion of test-particles into sets of existing
    2D coordinates, averaged over bins of width dr, and based on the pairwise 
    interaction potential u(r) (in units of kT).
    
    Implementation partly based on ref. [1] but with novel corrections for 
    edge effects based on analytical formulas for periodic and nonperiodic 
    boundary conditions.

    Parameters
    ----------
    coordinates : list-like of numpy.array
        List of sets of coordinates, where each item along the 0th dimension is
        a n*2 numpy.array of particle coordinates, where each array is an 
        independent set of coordinates (e.g. one time step from a video, etc.),
        with each element of the array of form  `[y,x]`. Each  set of 
        coordinates is not required to have the same number of particles but 
        all stacks must share the same  bounding box as given by  `boundary`, 
        and all coordinates must be within this bounding box.
    pairpotential : iterable
        list of values for the pairwise interaction potential. Must have length
        of `len(pairpotential_binedges)-1` and be in units of thermal energy kT
    rmax : float
        cut-off radius for the pairwise distance (right edge of last bin).
    dr : float
        bin width of the pairwise distance bins.
    boundary : array-like of form `((ymin,ymax),(xmin,xmax))`
        positions of the walls that define the bounding box of the coordinates.
    pairpotential_binedges : iterable, optional
        bin edges corresponding to the values in `pairpotential. The default 
        is None, which uses the bins defined by `rmin`, `rmax` and `dr`.
    n_ins : int, optional
        the number of test-particles to insert into each item in `coordinates`.
        The default is 1000.
    interpolate : bool, optional
        whether to use linear interpolation for calculating the interaction of 
        two particles using the values in `pairpotential`. The default is True.
        If False, the nearest bin value is used.
    rmin : float, optional
        lower cut-off for the pairwise distance. The default is 0.
    periodic_boundary : bool, optional
        whether periodic boundary conditions are used. The default is False.
    avoid_boundary : bool, optional
        if True, all test-particles are inserted at least `rmax` away from any 
        of the surfaces defined in `boundary` to avoid effects of the finite
        volume of the bounding box. The default is False, which uses an 
        analytical correction factor for missing volume of test-particles near 
        the boundaries.
    avoid_coordinates : bool, optional
        whether to insert test-particles at least `rmin` away from the center 
        of any of the &#39;real&#39; coordinates in `coordinates`. The default is 
        False.

    Returns
    -------
    pair_correlation : numpy.array
        values for the rdf / pair correlation function in each bin
    counter : numpy.array
        number of pair counts that contributed to the (mean) values in each bin
    
    References
    ----------
    [1] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2019). Model-
    Free Measurement of the Pair Potential in Colloidal Fluids Using Optical 
    Microscopy. Physical Review Letters, 123(9), 098002. 
    https://doi.org/10.1103/PhysRevLett.123.098002
    
    &#34;&#34;&#34;

    #assure array of arrays with first axis as dtype=object and rest floats
    if type(coordinates)==list:#weird syntax but there&#39;s no prettier way
        coordinates = np.array([None]+coordinates,dtype=object)[1:]
    
    elif type(coordinates)==np.ndarray:
        if not np.can_cast(coordinates[0].dtype,float):
            raise TypeError(
                &#34;dtype `{}` of `coordinates` can&#39;t be broadcasted to `float`&#34;.format(coordinates[0].dtype)
            )
    else:
        raise TypeError(
            &#34;dtype `{}` of `coordinates` not supported, use a list of numpy.array&#34;.format(type(coordinates))
        )
    
    #assure 3D array for coordinates
    if coordinates.ndim == 2:
        coordinates = coordinates[np.newaxis,:,:]

    #check if rmax input and boundary are feasible for avoiding boundary
    boundary = np.array(boundary)
    if avoid_boundary and rmax &gt;= min(boundary[:,1]-boundary[:,0])/2:
        raise ValueError(
            &#39;rmax cannot be more than half the smallest box dimension when &#39;+
            &#39;avoid_boundary=True, use rmax &lt; {:}&#39;.format(min(boundary[:,1]-boundary[:,0])/2)
        )
    
    #check rmax and boundary for edge-handling in periodic boundary conditions
    elif periodic_boundary:
        if boundary[0,1]-boundary[0,0] == boundary[1,1]-boundary[1,0]:
            boxlen = boundary[0,1]-boundary[0,0]
            if rmax &gt; boxlen*np.sqrt(2)/2:
                raise ValueError(
                    &#39;rmax cannot be more than sqrt(2)/2 times the size of a &#39;+
                    &#39;square bounding box when periodic_boundary=True, use &#39;+
                    &#39;rmax &lt; {:}&#39;.format((boundary[0,1]-boundary[0,0])*np.sqrt(2)/2)
                )
        elif rmax &gt; min(boundary[:,1]-boundary[:,0]):
            raise NotImplementedError(
                &#39;rmax larger than half the smallest box dimension when &#39;+
                &#39;periodic_boundary=True is only implemented for square boundaries&#39;
            )
    
    #check rmax and boundary for edge handling without periodic boundaries
    else:
        if rmax &gt; max(boundary[:,1]-boundary[:,0])/2:
            raise ValueError(
                &#39;rmax cannot be larger than half the largest dimension in &#39;+
                &#39;boundary, use rmax &lt; {:}&#39;.format(max(boundary[:,1]-boundary[:,0])/2)
            )
    
    #create bin edges and bin centres for r
    rvals = np.arange(rmin,rmax+dr,dr)
    rcent = rvals[:-1]+dr/2
    nt = len(coordinates)
    nr = len(rcent)
    
    #bin edges and centres for pairpotential
    if type(pairpotential_binedges) == type(None):
        pairpotential_binedges = rvals
    pairpotential_bincenter = (pairpotential_binedges[1:]+pairpotential_binedges[:-1])/2
    
    #init function that returns energy from list of pairwise distances
    if interpolate:#linearly interpolate pair potential between points
        pot_fun = lambda dist: np.interp(dist,pairpotential_bincenter,
                                         pairpotential)
    else:#get pair potential from nearest bin (round r to bincenter)
        from scipy.interpolate import interp1d    
        pot_fun = interp1d(pairpotential_bincenter,pairpotential,
                           kind=&#39;nearest&#39;,bounds_error=False,
                           fill_value=&#39;extrapolate&#39;)
    
    #define a reduced area for test-particles away from all boundaries
    if avoid_boundary:
        reduced_boundary = boundary.copy()
        reduced_boundary[:,0] += rmax
        reduced_boundary[:,1] -= rmax
    
    #initialize arrays to store values
    counter = np.empty((nt,nr))
    pair_correlation = np.empty((nt,nr))
    
    #loop over all timesteps / independent sets of coordiates
    for i,coords in enumerate(coordinates):
        
        #generate new test-particle coordinates for each set
        if avoid_coordinates and avoid_boundary:
            trialparticles = _rand_coord_at_dist(reduced_boundary,coords,rmin,n=n_ins)
        elif avoid_coordinates:
            trialparticles = _rand_coord_at_dist(boundary,coords,rmin,n=n_ins)
        elif avoid_boundary:
            trialparticles = _rand_coord_in_box(reduced_boundary,n=n_ins)
        else:
            trialparticles = _rand_coord_in_box(boundary,n=n_ins)
         
        #init KDTree for fast pairfinding
        if periodic_boundary:
            coords -= boundary[:,0]#shift box to origin
            tree = cKDTree(coords,boxsize=boundary[:,1]-boundary[:,0])
        else:
            tree = cKDTree(coords)
        
        #find all pairs with one particle from testparticles and one from coordinates
        distances,_ = tree.query(trialparticles,k=len(coords),distance_upper_bound=rmax)
        
        #cKDTree pads rows with np.inf to get correct length, work with masked
        #arrays to only work on finite values
        mask = np.isfinite(distances) &amp; (distances&gt;0)
        distances = np.ma.masked_array(distances,mask)
        
        #calculate total potential energy of insertion (psi) for each testparticle
        #(row) by summing each pairwise potential energy u(r)
        if avoid_boundary:
            exp_psi = np.apply_along_axis(
                lambda row: np.exp(-np.sum(pot_fun(row.data[row.mask]))),
                1,
                distances
            )
        else:
            if periodic_boundary:
                #calculate correction factor for each distance bin to account 
                # for missing information
                boundarycorr = _circle_ring_area_frac_periodic(
                    rvals,
                    min(boundary[:,1]-boundary[:,0])
                )[np.newaxis,:]
                
            else:
                #calculate correction factor for each testparticle for each dist bin
                # to account for missing information around particles near boundary.
                #boundary is shifted for coordinate system with origin in particle
                boundarycorr = _circle_ring_area_fraction(
                    rvals,
                    boundary-trialparticles[:,:,np.newaxis]
                )
                
            #sum pairwise energy per particle per distance bin, then correct
            # each bin for missing volume, then sum and convert to probability 
            # e^(-psi)
            exp_psi = np.apply_along_axis(
                lambda row: np.histogram(
                    row.data[row.mask],
                    bins=rvals,
                    weights=pot_fun(row.data[row.mask])
                    )[0],
                1,
                distances
            )
            
            #calculate probability of testparticles
            exp_psi = np.exp(-np.sum(exp_psi/boundarycorr,axis=1))
            
        #calculate average probability of all testparticles
        prob_tot = np.mean(exp_psi)
        
        #count how many pairs each particle contributes to each bin, apply
        # boundary correction for correctly weighted average
        prob_r = np.apply_along_axis(
            lambda row: np.histogram(row.data[row.mask],bins=rvals)[0],1,distances)
        
        #boundarycorrect probability counts for correct weighing
        if not avoid_boundary:
            prob_r = prob_r / boundarycorr 
        
        counts = prob_r.sum(axis=0)
        
        #take average of test-particle probabilities in each bin weighted by number
        # of pair counts
        prob_r = np.sum(prob_r * exp_psi[:,np.newaxis], axis=0)
        prob_r[counts!=0] /= counts[counts!=0]
        
        #store to lists
        counter[i] = counts
        pair_correlation[i] = prob_r/prob_tot
    
    pair_correlation = np.sum(pair_correlation*counter,axis=0)
    counter = counter.sum(axis=0)
    pair_correlation[counter!=0] /= counter[counter!=0]
    pair_correlation[counter==0] = 0
    
    return pair_correlation,counter</code></pre>
</details>
</dd>
<dt id="potentials_from_particle_insertion.rdf_insertion_binned_3d"><code class="name flex">
<span>def <span class="ident">rdf_insertion_binned_3d</span></span>(<span>coordinates, pairpotential, rmax, dr, boundary, pairpotential_binedges=None, n_ins=1000, interpolate=True, rmin=0, periodic_boundary=False, avoid_boundary=False, avoid_coordinates=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate g(r) from insertion of test-particles into sets of existing
3D coordinates, averaged over bins of width dr, and based on the pairwise
interaction potential u(r) (in units of kT).</p>
<p>Implementation partly based on ref. [1] but with novel corrections for
edge effects based on analytical formulas from refs. [2] and [3] for
periodic and nonperiodic boundary conditions respectively.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list</code>-<code>like</code> of <code>numpy.array</code></dt>
<dd>List of sets of coordinates, where each item along the 0th dimension is
a n*3 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one z-stack, a time step from a
video, etc.), with each element of the array of form
<code>[z,y,x]</code>. Each
set of coordinates is not required to have the same number of particles
but all stacks must share the same
bounding box as given by
<code>boundary</code>, and all coordinates must be within this bounding box.</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>iterable</code></dt>
<dd>list of values for the pairwise interaction potential. Must have length
of <code>len(pairpotential_binedges)-1</code> and be in units of thermal energy kT</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>cut-off radius for the pairwise distance (right edge of last bin).</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code></dt>
<dd>bin width of the pairwise distance bins.</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array</code>-<code>like</code> of <code>form</code> <code>((</code>zmin<code>,</code>zmax<code>),(</code>ymin<code>,</code>ymax<code>),(</code>xmin<code>,</code>xmax<code>))</code></dt>
<dd>positions of the walls that define the bounding box of the coordinates.</dd>
<dt><strong><code>pairpotential_binedges</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>bin edges corresponding to the values in <code>pairpotential. The default
is None, which uses the bins defined by</code>rmin<code>,</code>rmax<code>and</code>dr`.</dd>
<dt><strong><code>n_ins</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of test-particles to insert into each item in <code>coordinates</code>.
The default is 1000.</dd>
<dt><strong><code>interpolate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to use linear interpolation for calculating the interaction of
two particles using the values in <code>pairpotential</code>. The default is True.
If False, the nearest bin value is used.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower cut-off for the pairwise distance. The default is 0.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether periodic boundary conditions are used. The default is False.</dd>
<dt><strong><code>avoid_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, all test-particles are inserted at least <code>rmax</code> away from any
of the surfaces defined in <code>boundary</code> to avoid effects of the finite
volume of the bounding box. The default is False, which uses an
analytical correction factor for missing volume of test-particles near
the boundaries.</dd>
<dt><strong><code>avoid_coordinates</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to insert test-particles at least <code>rmin</code> away from the center
of any of the 'real' coordinates in <code>coordinates</code>. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pair_correlation</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>values for the rdf / pair correlation function in each bin</dd>
<dt><strong><code>counter</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>number of pair counts that contributed to the (mean) values in each bin</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2019). Model-
Free Measurement of the Pair Potential in Colloidal Fluids Using Optical
Microscopy. Physical Review Letters, 123(9), 098002.
<a href="https://doi.org/10.1103/PhysRevLett.123.098002">https://doi.org/10.1103/PhysRevLett.123.098002</a></p>
<p>[2] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
periodic boundary conditions.
<a href="https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf">https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf</a></p>
<p>[3] Kopera, B. A. F., &amp; Retsch, M. (2018). Computing the 3D Radial
Distribution Function from Particle Positions: An Advanced Analytic
Approach. Analytical Chemistry, 90(23), 13909–13914.
<a href="https://doi.org/10.1021/acs.analchem.8b03157">https://doi.org/10.1021/acs.analchem.8b03157</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rdf_insertion_binned_3d(coordinates,pairpotential,rmax,dr,boundary,
                            pairpotential_binedges=None,n_ins=1000,
                            interpolate=True,rmin=0,periodic_boundary=False,
                            avoid_boundary=False,avoid_coordinates=False):
    &#34;&#34;&#34;Calculate g(r) from insertion of test-particles into sets of existing
    3D coordinates, averaged over bins of width dr, and based on the pairwise 
    interaction potential u(r) (in units of kT).
    
    Implementation partly based on ref. [1] but with novel corrections for 
    edge effects based on analytical formulas from refs. [2] and [3] for 
    periodic and nonperiodic boundary conditions respectively.

    Parameters
    ----------
    coordinates : list-like of numpy.array
        List of sets of coordinates, where each item along the 0th dimension is
        a n*3 numpy.array of particle coordinates, where each array is an 
        independent set of coordinates (e.g. one z-stack, a time step from a 
        video, etc.), with each element of the array of form  `[z,y,x]`. Each 
        set of coordinates is not required to have the same number of particles
        but all stacks must share the same  bounding box as given by 
        `boundary`, and all coordinates must be within this bounding box.
    pairpotential : iterable
        list of values for the pairwise interaction potential. Must have length
        of `len(pairpotential_binedges)-1` and be in units of thermal energy kT
    rmax : float
        cut-off radius for the pairwise distance (right edge of last bin).
    dr : float
        bin width of the pairwise distance bins.
    boundary : array-like of form `((zmin,zmax),(ymin,ymax),(xmin,xmax))`
        positions of the walls that define the bounding box of the coordinates.
    pairpotential_binedges : iterable, optional
        bin edges corresponding to the values in `pairpotential. The default 
        is None, which uses the bins defined by `rmin`, `rmax` and `dr`.
    n_ins : int, optional
        the number of test-particles to insert into each item in `coordinates`.
        The default is 1000.
    interpolate : bool, optional
        whether to use linear interpolation for calculating the interaction of 
        two particles using the values in `pairpotential`. The default is True.
        If False, the nearest bin value is used.
    rmin : float, optional
        lower cut-off for the pairwise distance. The default is 0.
    periodic_boundary : bool, optional
        whether periodic boundary conditions are used. The default is False.
    avoid_boundary : bool, optional
        if True, all test-particles are inserted at least `rmax` away from any 
        of the surfaces defined in `boundary` to avoid effects of the finite
        volume of the bounding box. The default is False, which uses an 
        analytical correction factor for missing volume of test-particles near 
        the boundaries.
    avoid_coordinates : bool, optional
        whether to insert test-particles at least `rmin` away from the center 
        of any of the &#39;real&#39; coordinates in `coordinates`. The default is 
        False.

    Returns
    -------
    pair_correlation : numpy.array
        values for the rdf / pair correlation function in each bin
    counter : numpy.array
        number of pair counts that contributed to the (mean) values in each bin
    
    References
    ----------
    [1] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2019). Model-
    Free Measurement of the Pair Potential in Colloidal Fluids Using Optical 
    Microscopy. Physical Review Letters, 123(9), 098002. 
    https://doi.org/10.1103/PhysRevLett.123.098002
    
    [2] Markus Seserno (2014). How to calculate a three-dimensional g(r) under
    periodic boundary conditions.
    https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf
    
    [3] Kopera, B. A. F., &amp; Retsch, M. (2018). Computing the 3D Radial 
    Distribution Function from Particle Positions: An Advanced Analytic 
    Approach. Analytical Chemistry, 90(23), 13909–13914. 
    https://doi.org/10.1021/acs.analchem.8b03157
    &#34;&#34;&#34;

    #assure array of arrays with first axis as dtype=object and rest floats
    if type(coordinates)==list:#weird syntax but there&#39;s no prettier way
        coordinates = np.array([None]+coordinates,dtype=object)[1:]
    
    elif type(coordinates)==np.ndarray:
        if not np.can_cast(coordinates[0].dtype,float):
            raise TypeError(
                &#34;dtype `{}` of `coordinates` can&#39;t be broadcasted to `float`&#34;.format(coordinates[0].dtype)
            )
    else:
        raise TypeError(
            &#34;dtype `{}` of `coordinates` not supported, use a list of numpy.array&#34;.format(type(coordinates))
        )
    
    #assure 3D array for coordinates
    if coordinates.ndim == 2:
        coordinates = coordinates[np.newaxis,:,:]

    #check if rmax input and boundary are feasible for avoiding boundary
    boundary = np.array(boundary)
    if avoid_boundary and rmax &gt;= min(boundary[:,1]-boundary[:,0])/2:
        raise ValueError(
            &#39;rmax cannot be more than half the smallest box dimension when &#39;+
            &#39;avoid_boundary=True, use rmax &lt; {:}&#39;.format(min(boundary[:,1]-boundary[:,0])/2)
        )
    
    #check rmax and boundary for edge-handling in periodic boundary conditions
    elif periodic_boundary:
        if min(boundary[:,1]-boundary[:,0])==max(boundary[:,1]-boundary[:,0]):
            boxlen = boundary[0,1]-boundary[0,0]
            if rmax &gt; boxlen*np.sqrt(3)/2:
                raise ValueError(
                    &#39;rmax cannot be more than sqrt(3)/2 times the size of a &#39;+
                    &#39;cubic bounding box when periodic_boundary=True, use &#39;+
                    &#39;rmax &lt; {:}&#39;.format((boundary[0,1]-boundary[0,0])*np.sqrt(3)/2)
                )
        elif rmax &gt; min(boundary[:,1]-boundary[:,0]):
            raise NotImplementedError(
                &#39;rmax larger than half the smallest box dimension when &#39;+
                &#39;periodic_boundary=True is only implemented for cubic boundaries&#39;
            )
    
    #check rmax and boundary for edge handling without periodic boundaries
    else:
        if rmax &gt; max(boundary[:,1]-boundary[:,0])/2:
            raise ValueError(
                &#39;rmax cannot be larger than half the largest dimension in &#39;+
                &#39;boundary, use rmax &lt; {:}&#39;.format(max(boundary[:,1]-boundary[:,0])/2)
            )
    
    #create bin edges and bin centres for r
    rvals = np.arange(rmin,rmax+dr,dr)
    rcent = rvals[:-1]+dr/2
    nt = len(coordinates)
    nr = len(rcent)
    
    #bin edges and centres for pairpotential
    if type(pairpotential_binedges) == type(None):
        pairpotential_binedges = rvals
    pairpotential_bincenter = (pairpotential_binedges[1:]+pairpotential_binedges[:-1])/2
    
    #init function that returns energy from list of pairwise distances
    if interpolate:#linearly interpolate pair potential between points
        pot_fun = lambda dist: np.interp(dist,pairpotential_bincenter,
                                         pairpotential)
    else:#get pair potential from nearest bin (round r to bincenter)
        from scipy.interpolate import interp1d    
        pot_fun = interp1d(pairpotential_bincenter,pairpotential,
                           kind=&#39;nearest&#39;,bounds_error=False,
                           fill_value=&#39;extrapolate&#39;)
    
    #define a reduced area for test-particles away from all boundaries
    if avoid_boundary:
        reduced_boundary = boundary.copy()
        reduced_boundary[:,0] += rmax
        reduced_boundary[:,1] -= rmax
    
    #initialize arrays to store values
    counter = np.empty((nt,nr))
    pair_correlation = np.empty((nt,nr))
    
    #loop over all timesteps / independent sets of coordiates
    for i,coords in enumerate(coordinates):
        
        #generate new test-particle coordinates for each set
        if avoid_coordinates and avoid_boundary:
            trialparticles = _rand_coord_at_dist(reduced_boundary,coords,rmin,n=n_ins)
        elif avoid_coordinates:
            trialparticles = _rand_coord_at_dist(boundary,coords,rmin,n=n_ins)
        elif avoid_boundary:
            trialparticles = _rand_coord_in_box(reduced_boundary,n=n_ins)
        else:
            trialparticles = _rand_coord_in_box(boundary,n=n_ins)
         
        #init KDTree for fast pairfinding
        if periodic_boundary:
            coords -= boundary[:,0]#shift box to origin
            tree = cKDTree(coords,boxsize=boundary[:,1]-boundary[:,0])
        else:
            tree = cKDTree(coords)
        
        #find all pairs with one particle from testparticles and one from coordinates
        distances,_ = tree.query(trialparticles,k=len(coords),distance_upper_bound=rmax)
        
        #cKDTree pads rows with np.inf to get correct length, work with masked
        #arrays to only work on finite values
        mask = np.isfinite(distances) &amp; (distances&gt;0)
        distances = np.ma.masked_array(distances,mask)
        
        #calculate total potential energy of insertion (psi) for each testparticle
        #(row) by summing each pairwise potential energy u(r)
        if avoid_boundary:
            exp_psi = np.apply_along_axis(
                lambda row: np.exp(-np.sum(pot_fun(row.data[row.mask]))),
                1,
                distances
            )
        else:
            if periodic_boundary:
                #calculate correction factor for each distance bin to account 
                # for missing information
                boundarycorr = _sphere_shell_vol_frac_periodic(
                    rvals,
                    min(boundary[:,1]-boundary[:,0])
                )[np.newaxis,:]
                
            else:
                #calculate correction factor for each testparticle for each dist bin
                # to account for missing information around particles near boundary.
                #boundary is shifted for coordinate system with origin in particle
                boundarycorr = _sphere_shell_vol_fraction(
                    rvals,
                    boundary-trialparticles[:,:,np.newaxis]
                )
                
            #sum pairwise energy per particle per distance bin, then correct
            # each bin for missing volume, then sum and convert to probability 
            # e^(-psi)
            exp_psi = np.apply_along_axis(
                lambda row: np.histogram(
                    row.data[row.mask],
                    bins=rvals,
                    weights=pot_fun(row.data[row.mask])
                    )[0],
                1,
                distances
            )
            
            #calculate probability of testparticles
            exp_psi = np.exp(-np.sum(exp_psi/boundarycorr,axis=1))
            
        #calculate average probability of all testparticles
        prob_tot = np.mean(exp_psi)
        
        #count how many pairs each particle contributes to each bin, apply
        # boundary correction for correctly weighted average
        prob_r = np.apply_along_axis(
            lambda row: np.histogram(row.data[row.mask],bins=rvals)[0],1,distances)
        
        #boundarycorrect probability counts for correct weighing
        if not avoid_boundary:
            prob_r = prob_r / boundarycorr 
        
        counts = prob_r.sum(axis=0)
        
        #take average of test-particle probabilities in each bin weighted by number
        # of pair counts
        prob_r = np.sum(prob_r * exp_psi[:,np.newaxis], axis=0)
        prob_r[counts!=0] /= counts[counts!=0]
        
        #store to lists
        counter[i] = counts
        pair_correlation[i] = prob_r/prob_tot
    
    pair_correlation = np.sum(pair_correlation*counter,axis=0)
    counter = counter.sum(axis=0)
    pair_correlation[counter!=0] /= counter[counter!=0]
    pair_correlation[counter==0] = 0
    
    return pair_correlation,counter</code></pre>
</details>
</dd>
<dt id="potentials_from_particle_insertion.rdf_insertion_exact_3d"><code class="name flex">
<span>def <span class="ident">rdf_insertion_exact_3d</span></span>(<span>coordinates, pairpotential, rmax, dr, boundary, pairpotential_binedges=None, gen_prob_reps=1000, shell_prob_reps=10, interpolate=True, use_numba=True)</span>
</code></dt>
<dd>
<section class="desc"><p>calculate g(r) from particle insertion method using particle coordinates
and pairwise interaction potential u(r) (in units of kT). Inserts test-
particles at a specific r for every real particle</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list</code> of <code>numpy.array</code> of <code>floats</code> of <code>shape</code> <code>nt</code><em><code>n</code></em><code>3</code></dt>
<dd>The coordinates of particles in the system</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>list</code> of <code>floats</code></dt>
<dd>the value of the interparticle potential in each bin of 0 to rmax+dr
in steps of dr. The value is assumed to correspond to the centrepoint
of the bins.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>cut-off value for the radius. Interactions beyond this range are
considered negligable. Right edge of last bin in the pair potential</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code></dt>
<dd>bin width/step size of the interparticle distance used for g(r) and the
pair potential.</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>tuple</code> of <code>floats</code> of <code>form</code> ((<code>zmin</code>,<code>zmax</code>),(<code>ymin</code>,<code>ymax</code>),(<code>xmin</code>,<code>xmax</code>))</dt>
<dd>defines the boundaries of the box in which coordinates may exist.</dd>
<dt><strong><code>gen_prob_reps</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of trial particles used to evaluate the general probability of
placing a particle at random coordinates in the box defined by
<code>boundary</code>. The default is 1000.</dd>
<dt><strong><code>shell_prob_reps</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of trial particles per reference coordinate in <code>coordinates</code>
used to evaluate the probability of placing a particle in each distance
bin. The default is 10.</dd>
<dt><strong><code>interpolate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, the pair potential is linearly interpolated between bin
centres to calculate the interactions between all pairs of particles.
If false, the value from the nearest bin is taken which is
slower to compute. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pair_correlation</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>the pair correlation / radial distribution functions evaluated in the
bins whose edges are defined by numpy.arange(0,rmax+dr,dr)</dd>
<dt><strong><code>counters</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>The number of trialparticles evaluated for each distance bin</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rdf_insertion_exact_3d(coordinates,pairpotential,rmax,dr,boundary,
                                 pairpotential_binedges=None,
                                 gen_prob_reps=1000,shell_prob_reps=10,
                                 interpolate=True,use_numba=True):
    &#34;&#34;&#34;calculate g(r) from particle insertion method using particle coordinates
    and pairwise interaction potential u(r) (in units of kT). Inserts test-
    particles at a specific r for every real particle

    Parameters
    ----------
    coordinates : list of numpy.array of floats of shape nt*n*3
        The coordinates of particles in the system
    pairpotential : list of floats
        the value of the interparticle potential in each bin of 0 to rmax+dr 
        in steps of dr. The value is assumed to correspond to the centrepoint
        of the bins.
    rmax : float
        cut-off value for the radius. Interactions beyond this range are 
        considered negligable. Right edge of last bin in the pair potential
    dr : float
        bin width/step size of the interparticle distance used for g(r) and the
        pair potential.
    boundary : tuple of floats of form ((zmin,zmax),(ymin,ymax),(xmin,xmax))
        defines the boundaries of the box in which coordinates may exist.
    gen_prob_reps : int, optional
        number of trial particles used to evaluate the general probability of
        placing a particle at random coordinates in the box defined by
        `boundary`. The default is 1000.
    shell_prob_reps : int, optional
        number of trial particles per reference coordinate in `coordinates` 
        used to evaluate the probability of placing a particle in each distance
        bin. The default is 10.
    interpolate : bool, optional
        If true, the pair potential is linearly interpolated between bin 
        centres to calculate the interactions between all pairs of particles. 
        If false, the value from the nearest bin is taken which is
        slower to compute. The default is True.

    Returns
    -------
    pair_correlation : list of float
        the pair correlation / radial distribution functions evaluated in the 
        bins whose edges are defined by numpy.arange(0,rmax+dr,dr)
    counters : list of int
        The number of trialparticles evaluated for each distance bin

    &#34;&#34;&#34;
    rvals = np.arange(0,rmax+dr,dr)#bins for r / u(r)
    rcent = rvals[:-1]+dr/2
    nt = len(coordinates)
    nr = len(rcent)
    
    if type(pairpotential_binedges) == type(None):
        pairpotential_binedges = rvals
    pairpotential_bincenter = (pairpotential_binedges[1:]+pairpotential_binedges[:-1])/2
    
    if interpolate:#interpolate pair potential between points
        pot_fun = lambda dist: np.interp(dist,pairpotential_bincenter,
                                         pairpotential)
    else:#get pair potential from nearest bin (round r to bincenter)
        from scipy.interpolate import interp1d    
        pot_fun = interp1d(pairpotential_bincenter,pairpotential,
                           kind=&#39;nearest&#39;,bounds_error=False,
                           fill_value=&#39;extrapolate&#39;)
    
    #calculate average probability over the whole box to insert particle
    tot_prob = 0
    for coords in coordinates:
        trialparticles = _rand_coord_in_box(boundary,n=gen_prob_reps)
        for trialparticle in trialparticles:
            if use_numba:
                distances = _calc_squared_dist_numba(coords,trialparticle,rmax)
            else:
                distances = _calc_squared_dist(coords,trialparticle,rmax)
            #correction factor for edge here?
            tot_prob += np.exp(-np.sum(pot_fun(np.sqrt(distances))))
    
    #check and stop in case of NaN values
    if np.isnan(tot_prob):
        raise SystemError(&#39;NaN value detected&#39;)
            
    tot_prob /= (gen_prob_reps*nt)
    
    #loop over all spherical shells at distances of bin centers of r bins
    probs = np.zeros(nr)
    counters = np.zeros(len(rcent),dtype=np.uint16)
    for i,r in enumerate(rcent):
        print(&#39;\rg(r): {:.0f}%&#39;.format(100*i/(nr-1)),end=&#39;&#39;)
        
        #loop over all sets of coordinates
        for coords in coordinates:
            
            #loop over all particles to act as reference particle in the origin
            for refcoords in coords:
                
                #create trialparticles at r from ref_particle
                trialcoords = _rand_coord_on_sphere(
                    npoints=shell_prob_reps,
                    radius=r,
                    origin=refcoords
                    )
                
                #loop over all trial particles around ref particle
                for trialparticle in trialcoords:
                    
                    #check if the trialparticle is within the box boundaries
                    if all([(coord&gt;=bb[0] and coord&lt;=bb[1]) for coord,bb in zip(trialparticle,boundary)]):
                        if use_numba:
                            distances = _calc_squared_dist_numba(coords,trialparticle,rmax)
                        else:
                            distances = _calc_squared_dist(coords,trialparticle,rmax)
    
                        probs[i] += np.exp(-np.sum(pot_fun(np.sqrt(distances))))
                        counters[i] +=1
                    
        probs[i] /= counters[i]
    
    pair_correlation = probs / tot_prob
    
    return pair_correlation,counters</code></pre>
</details>
</dd>
<dt id="potentials_from_particle_insertion.run_iteration"><code class="name flex">
<span>def <span class="ident">run_iteration</span></span>(<span>coordinates, pair_correlation_func, boundary, initial_guess=None, rmin=0, rmax=20, dr=0.5, convergence_tol=1e-05, max_iterations=100, zero_clip=1e-20, regulate=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Run the algorithm to solve for the pairwise potential that most accurately
reproduces the radial distribution function using test-particle insertion,
as described in ref. [1]. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list</code>-<code>like</code> of <code>numpy.array</code></dt>
<dd>List of sets of coordinates, where each item along the 0th dimension is
a n*3 numpy.array of particle coordinates, where each array is an
independent set of coordinates (e.g. one z-stack, a time step from a
video, etc.), with each element of the array of form
<code>[z,y,x]</code> or
<code>[y,x]</code> in case of 2D data. Each set of coordinates is not required to
have the same number of particles but all stacks must share the same
bounding box as given by <code>boundary</code>, and all coordinates must be within
this bounding box.</dd>
<dt><strong><code>pair_correlation_func</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>bin values for the true pair correlation function that the algorithm
will try to match iteratively.</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array</code>-<code>like</code> of <code>form</code> <code>([(</code>zmin<code>,</code>zmax<code>),](</code>ymin<code>,</code>ymax<code>),(</code>xmin<code>,</code>xmax<code>))</code></dt>
<dd>positions of the walls that define the bounding box of the coordinates.
Number of dimensions must match coordinates.</dd>
<dt><strong><code>initial_guess</code></strong> :&ensp;<code>list</code> of <code>float</code>, optional</dt>
<dd>Initial guess for the particle potential on the 0th iteration. The
default is None which gives 0 in each bin.</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>left edge of the smallest bin in interparticle distance r to consider.
The default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Right edge of the largest bin in interparticle distance r to consider.
The default is 20.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Stepsize or bin width in interparticle distance r. The default is 0.5.</dd>
<dt><strong><code>convergence_tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>target value for χ², if it dips below this value the iteration is
considered to be converged and ended. The default is <code>1e-5</code>.</dd>
<dt><strong><code>max_iterations</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of iterations after which the algorithm is ended. The
default is 100.</dd>
<dt><strong><code>zero_clip</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>values below the value of zero-clip are set to this value to avoid
devision by zero errors. The default is <code>1e-20</code>.</dd>
<dt><strong><code>regulate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, use regularization to more gently nudge towards the input g(r)
at the cost of slower convergence. Experimental option. The default is
<code>False</code>.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>key</code>=<code>value</code></dt>
<dd>Additional keyword arguments are passed on to <a title="potentials_from_particle_insertion.rdf_insertion_binned_2d" href="#potentials_from_particle_insertion.rdf_insertion_binned_2d"><code>rdf_insertion_binned_2d()</code></a>
or <a title="potentials_from_particle_insertion.rdf_insertion_binned_3d" href="#potentials_from_particle_insertion.rdf_insertion_binned_3d"><code>rdf_insertion_binned_3d()</code></a></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>χ²</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>summed squared error in the pair correlation function for each
iteration</dd>
<dt><strong><code>pairpotential</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>the values for the pair potential in each bin for each iteration</dd>
<dt><strong><code>paircorrelation</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>the values for the pair correlation function from test-particle
insertion for each iteration</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2019). Model-
Free Measurement of the Pair Potential in Colloidal Fluids Using Optical
Microscopy. Physical Review Letters, 123(9), 098002.
<a href="https://doi.org/10.1103/PhysRevLett.123.098002">https://doi.org/10.1103/PhysRevLett.123.098002</a></p>
<h2 id="see-also">See also</h2>
<dl>
<dt><a title="potentials_from_particle_insertion.rdf_insertion_binned_2d" href="#potentials_from_particle_insertion.rdf_insertion_binned_2d"><code>rdf_insertion_binned_2d()</code></a></dt>
<dd>2D routine for g(r) from test-particle insertion</dd>
<dt><a title="potentials_from_particle_insertion.rdf_insertion_binned_3d" href="#potentials_from_particle_insertion.rdf_insertion_binned_3d"><code>rdf_insertion_binned_3d()</code></a></dt>
<dd>3D routine for g(r) from test-particle insertion</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_iteration(coordinates,pair_correlation_func,boundary,
                  initial_guess=None,rmin=0,rmax=20,dr=0.5,
                  convergence_tol=1e-5,max_iterations=100,zero_clip=1e-20,
                  regulate=False,**kwargs):
    &#34;&#34;&#34;
    Run the algorithm to solve for the pairwise potential that most accurately
    reproduces the radial distribution function using test-particle insertion,
    as described in ref. [1]. 

    Parameters
    ----------
    coordinates : list-like of numpy.array
        List of sets of coordinates, where each item along the 0th dimension is
        a n*3 numpy.array of particle coordinates, where each array is an 
        independent set of coordinates (e.g. one z-stack, a time step from a 
        video, etc.), with each element of the array of form  `[z,y,x]` or 
        `[y,x]` in case of 2D data. Each set of coordinates is not required to 
        have the same number of particles but all stacks must share the same 
        bounding box as given by `boundary`, and all coordinates must be within
        this bounding box.
    pair_correlation_func : list of float
        bin values for the true pair correlation function that the algorithm 
        will try to match iteratively.
    boundary : array-like of form `([(zmin,zmax),](ymin,ymax),(xmin,xmax))`
        positions of the walls that define the bounding box of the coordinates.
        Number of dimensions must match coordinates.
    initial_guess : list of float, optional
        Initial guess for the particle potential on the 0th iteration. The 
        default is None which gives 0 in each bin.
    rmin : float, optional
        left edge of the smallest bin in interparticle distance r to consider.
        The default is 0.
    rmax : float, optional
        Right edge of the largest bin in interparticle distance r to consider.
        The default is 20.
    dr : float, optional
        Stepsize or bin width in interparticle distance r. The default is 0.5.
    convergence_tol : float, optional
        target value for χ², if it dips below this value the iteration is 
        considered to be converged and ended. The default is `1e-5`.
    max_iterations : int, optional
        Maximum number of iterations after which the algorithm is ended. The
        default is 100.
    zero_clip : float, optional
        values below the value of zero-clip are set to this value to avoid
        devision by zero errors. The default is `1e-20`.
    regulate : bool, optional
        if True, use regularization to more gently nudge towards the input g(r)
        at the cost of slower convergence. Experimental option. The default is
        `False`.
    **kwargs : key=value
        Additional keyword arguments are passed on to `rdf_insertion_binned_2d`
        or `rdf_insertion_binned_3d`

    Returns
    -------
    χ² : list of float
        summed squared error in the pair correlation function for each 
        iteration
    pairpotential : list of list of float
        the values for the pair potential in each bin for each iteration
    paircorrelation : list of list of float
        the values for the pair correlation function from test-particle
        insertion for each iteration
    
    References
    ----------
    [1] Stones, A. E., Dullens, R. P. A., &amp; Aarts, D. G. A. L. (2019). Model-
    Free Measurement of the Pair Potential in Colloidal Fluids Using Optical 
    Microscopy. Physical Review Letters, 123(9), 098002. 
    https://doi.org/10.1103/PhysRevLett.123.098002
    
    See also
    --------
    rdf_insertion_binned_2d : 2D routine for g(r) from test-particle insertion
    rdf_insertion_binned_3d : 3D routine for g(r) from test-particle insertion
    &#34;&#34;&#34;
    
    #create values for bin edges and centres of r
    rvals = np.arange(rmin,rmax+dr,dr)
    rcent = rvals[:-1]+dr/2
    
    #check inputs
    if len(pair_correlation_func) != len(rcent):
        raise ValueError(&#39;lenght pair_correlation_func does not match rmax and dr&#39;)
    
    if type(initial_guess)==type(None):
        initial_guess = np.zeros(len(rcent))
    
    #check dimensionality, select appropriate rdf_insertion routine
    if len(boundary) == 2:
        rdf_insertion_binned = rdf_insertion_binned_2d
    elif len(boundary) == 3:
        rdf_insertion_binned = rdf_insertion_binned_3d
    else:
        raise ValueError(&#39;data and boundaries must be 2- or 3-dimensional&#39;)
      
    #set up for 0th iteration seperately
    pairpotential = [initial_guess]
    pair_correlation_func[pair_correlation_func&lt;zero_clip]=zero_clip
    newpaircorrelation,_ = rdf_insertion_binned(coordinates,initial_guess,
                                                rmax,dr,boundary,rmin=rmin,
                                                **kwargs)
    newpaircorrelation[newpaircorrelation&lt;zero_clip] = zero_clip#avoid deviding by zero
    paircorrelation = [newpaircorrelation]
    chi_squared = [np.mean((newpaircorrelation - pair_correlation_func)**2)]
    print(&#39;\riteration 0, χ²={:4g}&#39;.format(chi_squared[-1]))
    
    #start the main iterative loop
    i = 1
    counters = []
    while i &lt; max_iterations:
        
        #calculate the new pairwise potential, with relaxation
        if regulate:
            newpotential = np.average(
                [
                    np.exp(-pairpotential[-1]),
                    np.exp(-pairpotential[-1])*pair_correlation_func/newpaircorrelation
                ],
                axis=0,
                weights=[0 if i&lt;2 else i, max_iterations-i]
                )
        else:
             newpotential = np.exp(-pairpotential[-1])*pair_correlation_func/newpaircorrelation   

        newpotential[newpotential&lt;zero_clip] = zero_clip
        newpotential = -np.log(newpotential)
        pairpotential.append(newpotential)
        
        #use it to calculate the new g(r)
        newpaircorrelation,c = rdf_insertion_binned(
            coordinates,
            newpotential,
            rmax,
            dr,
            boundary,
            rmin=rmin,
            **kwargs)
        counters.append(c)
        newpaircorrelation[newpaircorrelation&lt;1e-10] = 1e-10
        #newpaircorrelation[newpaircorrelation&gt;20] = 20
        paircorrelation.append(newpaircorrelation)
        
        #calculate summed squared error
        chi_squared.append(np.mean((newpaircorrelation - pair_correlation_func)**2))
        
        print(&#39;\riteration {:}, χ²={:4g}&#39;.format(i,chi_squared[-1]))
        if chi_squared[-1] &lt; convergence_tol:
            break
        
        i += 1
    
    return chi_squared,pairpotential,paircorrelation,counters</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="potentials_from_particle_insertion.rdf_dist_hist_2d" href="#potentials_from_particle_insertion.rdf_dist_hist_2d">rdf_dist_hist_2d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_dist_hist_3d" href="#potentials_from_particle_insertion.rdf_dist_hist_3d">rdf_dist_hist_3d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_insertion_binned_2d" href="#potentials_from_particle_insertion.rdf_insertion_binned_2d">rdf_insertion_binned_2d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_insertion_binned_3d" href="#potentials_from_particle_insertion.rdf_insertion_binned_3d">rdf_insertion_binned_3d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.rdf_insertion_exact_3d" href="#potentials_from_particle_insertion.rdf_insertion_exact_3d">rdf_insertion_exact_3d</a></code></li>
<li><code><a title="potentials_from_particle_insertion.run_iteration" href="#potentials_from_particle_insertion.run_iteration">run_iteration</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>